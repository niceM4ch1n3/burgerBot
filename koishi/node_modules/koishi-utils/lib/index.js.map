{
  "version": 3,
  "sources": ["../src/index.ts", "../src/chinese.ts", "../src/logger.ts", "../src/time.ts", "../src/misc.ts", "../src/observe.ts", "../src/random.ts", "../src/segment.ts", "../src/set.ts", "../src/string.ts"],
  "sourcesContent": ["export * from './chinese'\nexport * from './logger'\nexport * from './misc'\nexport * from './observe'\nexport * from './random'\nexport * from './segment'\nexport * from './set'\nexport * from './string'\nexport * from './time'\n", "import { readFileSync } from 'fs'\nimport { resolve } from 'path'\n\nconst [simplified, traditional] = readFileSync(resolve(__dirname, '../chinese.txt'), 'utf-8').split(/\\r?\\n/)\n\nconst stMap = new Map<string, string>()\nconst tsMap = new Map<string, string>()\n\nsimplified.split('').forEach((char, index) => {\n  stMap.set(char, traditional[index])\n  tsMap.set(traditional[index], char)\n})\n\nexport function traditionalize(source: string) {\n  let result = ''\n  for (const char of source) {\n    result += stMap.get(char) || char\n  }\n  return result\n}\n\nexport function simplify(source: string) {\n  let result = ''\n  for (const char of source) {\n    result += tsMap.get(char) || char\n  }\n  return result\n}\n", "import { inspect, InspectOptions, format } from 'util'\nimport { clearScreenDown, cursorTo } from 'readline'\nimport { stderr } from 'supports-color'\nimport { Time } from './time'\n\nconst colors = stderr && stderr.level >= 2 ? [\n  20, 21, 26, 27, 32, 33, 38, 39, 40, 41, 42, 43, 44, 45, 56, 57, 62,\n  63, 68, 69, 74, 75, 76, 77, 78, 79, 80, 81, 92, 93, 98, 99, 112, 113,\n  129, 134, 135, 148, 149, 160, 161, 162, 163, 164, 165, 166, 167, 168,\n  169, 170, 171, 172, 173, 178, 179, 184, 185, 196, 197, 198, 199, 200,\n  201, 202, 203, 204, 205, 206, 207, 208, 209, 214, 215, 220, 221,\n] : [6, 2, 3, 4, 5, 1]\n\nconst instances: Record<string, Logger> = {}\n\nexport interface LogLevelConfig {\n  base: number\n  [K: string]: LogLevel\n}\n\ntype LogLevel = number | LogLevelConfig\ntype LogFunction = (format: any, ...param: any[]) => void\ntype LogType = 'success' | 'error' | 'info' | 'warn' | 'debug'\n\nexport interface Logger extends Record<LogType, LogFunction> {}\n\nexport class Logger {\n  static readonly SILENT = 0\n  static readonly SUCCESS = 1\n  static readonly ERROR = 1\n  static readonly INFO = 2\n  static readonly WARN = 2\n  static readonly DEBUG = 3\n\n  static showDiff = false\n  static showTime = ''\n  static timestamp = 0\n  static stream: NodeJS.WritableStream = process.stderr\n\n  static levels: LogLevelConfig = {\n    base: 2,\n  }\n\n  static options: InspectOptions = {\n    colors: stderr && stderr.hasBasic,\n  }\n\n  static formatters: Record<string, (this: Logger, value: any) => string> = {\n    c: Logger.prototype.color,\n    C: value => Logger.color(15, value, ';1'),\n    o: value => inspect(value, Logger.options).replace(/\\s*\\n\\s*/g, ' '),\n  }\n\n  static color(code: number, value: any, decoration = '') {\n    if (!Logger.options.colors) return '' + value\n    return `\\u001B[3${code < 8 ? code : '8;5;' + code}${decoration}m${value}\\u001B[0m`\n  }\n\n  static clearScreen() {\n    if (!Logger.stream['isTTY'] || process.env.CI) return\n    const blank = '\\n'.repeat(Math.max(Logger.stream['rows'] - 2, 0))\n    console.log(blank)\n    cursorTo(Logger.stream, 0, 0)\n    clearScreenDown(Logger.stream)\n  }\n\n  private code: number\n  private displayName: string\n\n  constructor(public name: string) {\n    if (name in instances) return instances[name]\n\n    let hash = 0\n    for (let i = 0; i < name.length; i++) {\n      hash = ((hash << 3) - hash) + name.charCodeAt(i)\n      hash |= 0\n    }\n    instances[name] = this\n    this.code = colors[Math.abs(hash) % colors.length]\n    this.displayName = this.color(name + ' ', ';1')\n    this.createMethod('success', '[S] ', Logger.SUCCESS)\n    this.createMethod('error', '[E] ', Logger.ERROR)\n    this.createMethod('info', '[I] ', Logger.INFO)\n    this.createMethod('warn', '[W] ', Logger.WARN)\n    this.createMethod('debug', '[D] ', Logger.DEBUG)\n  }\n\n  private color(value: any, decoration = '') {\n    return Logger.color(this.code, value, decoration)\n  }\n\n  private createMethod(name: LogType, prefix: string, minLevel: number) {\n    this[name] = (...args: [any, ...any[]]) => {\n      if (this.level < minLevel) return\n      let indent = 4, output = ''\n      if (Logger.showTime) {\n        indent += Logger.showTime.length + 1\n        output += Time.template(Logger.showTime + ' ')\n      }\n      output += prefix + this.displayName + this.format(indent, ...args)\n      if (Logger.showDiff) {\n        const now = Date.now()\n        const diff = Logger.timestamp && now - Logger.timestamp\n        output += this.color(' +' + Time.formatTimeShort(diff))\n        Logger.timestamp = now\n      }\n      Logger.stream.write(output + '\\n')\n    }\n  }\n\n  get level() {\n    const paths = this.name.split(':')\n    let config: LogLevel = Logger.levels\n    do {\n      config = config[paths.shift()] ?? config['base']\n    } while (paths.length && typeof config === 'object')\n    return config as number\n  }\n\n  set level(value) {\n    const paths = this.name.split(':')\n    let config = Logger.levels\n    while (paths.length > 1) {\n      const name = paths.shift()\n      const value = config[name]\n      if (typeof value === 'object') {\n        config = value\n      } else {\n        config = config[name] = { base: value ?? config.base }\n      }\n    }\n    config[paths[0]] = value\n  }\n\n  extend = (namespace: string) => {\n    return new Logger(`${this.name}:${namespace}`)\n  }\n\n  private format(indent: number, ...args: any[]) {\n    if (args[0] instanceof Error) {\n      args[0] = args[0].stack || args[0].message\n    } else if (typeof args[0] !== 'string') {\n      args.unshift('%O')\n    }\n\n    let index = 0\n    args[0] = (args[0] as string).replace(/%([a-zA-Z%])/g, (match, format) => {\n      if (match === '%%') return '%'\n      index += 1\n      const formatter = Logger.formatters[format]\n      if (typeof formatter === 'function') {\n        match = formatter.call(this, args[index])\n        args.splice(index, 1)\n        index -= 1\n      }\n      return match\n    }).replace(/\\n/g, '\\n' + ' '.repeat(indent))\n\n    return format(...args)\n  }\n}\n", "export namespace Time {\n  export const millisecond = 1\n  export const second = 1000\n  export const minute = second * 60\n  export const hour = minute * 60\n  export const day = hour * 24\n  export const week = day * 7\n\n  let timezoneOffset = new Date().getTimezoneOffset()\n\n  export function setTimezoneOffset(offset: number) {\n    timezoneOffset = offset\n  }\n\n  export function getTimezoneOffset() {\n    return timezoneOffset\n  }\n\n  export function getDateNumber(date: number | Date = new Date(), offset?: number) {\n    if (typeof date === 'number') date = new Date(date)\n    if (offset === undefined) offset = timezoneOffset\n    return Math.floor((date.valueOf() / minute - offset) / 1440)\n  }\n\n  export function fromDateNumber(value: number, offset?: number) {\n    const date = new Date(value * day)\n    if (offset === undefined) offset = timezoneOffset\n    return new Date(+date + offset * minute)\n  }\n\n  const numeric = /\\d+(?:\\.\\d+)?/.source\n  const timeRegExp = new RegExp(`^${[\n    'w(?:eek(?:s)?)?',\n    'd(?:ay(?:s)?)?',\n    'h(?:our(?:s)?)?',\n    'm(?:in(?:ute)?(?:s)?)?',\n    's(?:ec(?:ond)?(?:s)?)?',\n  ].map(unit => `(${numeric}${unit})?`).join('')}$`)\n\n  export function parseTime(source: string) {\n    const capture = timeRegExp.exec(source)\n    if (!capture) return 0\n    return (parseFloat(capture[1]) * week || 0)\n      + (parseFloat(capture[2]) * day || 0)\n      + (parseFloat(capture[3]) * hour || 0)\n      + (parseFloat(capture[4]) * minute || 0)\n      + (parseFloat(capture[5]) * second || 0)\n  }\n\n  export function parseDate(date: string) {\n    const parsed = parseTime(date)\n    if (parsed) {\n      date = Date.now() + parsed as any\n    } else if (/^\\d{1,2}(:\\d{1,2}){1,2}$/.test(date)) {\n      date = `${new Date().toLocaleDateString()}-${date}`\n    } else if (/^\\d{1,2}-\\d{1,2}-\\d{1,2}(:\\d{1,2}){1,2}$/.test(date)) {\n      date = `${new Date().getFullYear()}-${date}`\n    }\n    return date ? new Date(date) : new Date()\n  }\n\n  export function formatTimeShort(ms: number) {\n    const abs = Math.abs(ms)\n    if (abs >= day - hour / 2) {\n      return Math.round(ms / day) + 'd'\n    } else if (abs >= hour - minute / 2) {\n      return Math.round(ms / hour) + 'h'\n    } else if (abs >= minute - second / 2) {\n      return Math.round(ms / minute) + 'm'\n    } else if (abs >= second) {\n      return Math.round(ms / second) + 's'\n    }\n    return ms + 'ms'\n  }\n\n  export function formatTime(ms: number) {\n    let result: string\n    if (ms >= day - hour / 2) {\n      ms += hour / 2\n      result = Math.floor(ms / day) + ' 天'\n      if (ms % day > hour) {\n        result += ` ${Math.floor(ms % day / hour)} 小时`\n      }\n    } else if (ms >= hour - minute / 2) {\n      ms += minute / 2\n      result = Math.floor(ms / hour) + ' 小时'\n      if (ms % hour > minute) {\n        result += ` ${Math.floor(ms % hour / minute)} 分钟`\n      }\n    } else if (ms >= minute - second / 2) {\n      ms += second / 2\n      result = Math.floor(ms / minute) + ' 分钟'\n      if (ms % minute > second) {\n        result += ` ${Math.floor(ms % minute / second)} 秒`\n      }\n    } else {\n      result = Math.round(ms / second) + ' 秒'\n    }\n    return result\n  }\n\n  const dayMap = ['日', '一', '二', '三', '四', '五', '六']\n\n  function toDigits(source: number, length = 2) {\n    return source.toString().padStart(length, '0')\n  }\n\n  export function template(template: string, time = new Date()) {\n    return template\n      .replace('yyyy', time.getFullYear().toString())\n      .replace('yy', time.getFullYear().toString().slice(2))\n      .replace('MM', toDigits(time.getMonth() + 1))\n      .replace('dd', toDigits(time.getDate()))\n      .replace('hh', toDigits(time.getHours()))\n      .replace('mm', toDigits(time.getMinutes()))\n      .replace('ss', toDigits(time.getSeconds()))\n      .replace('SSS', toDigits(time.getMilliseconds(), 3))\n  }\n\n  function toHourMinute(time: Date) {\n    return `${toDigits(time.getHours())}:${toDigits(time.getMinutes())}`\n  }\n\n  export function formatTimeInterval(time: Date, interval?: number) {\n    if (!interval) {\n      return template('yyyy-MM-dd hh:mm:ss', time)\n    } else if (interval === day) {\n      return `每天 ${toHourMinute(time)}`\n    } else if (interval === week) {\n      return `每周${dayMap[time.getDay()]} ${toHourMinute(time)}`\n    } else {\n      return `${template('yyyy-MM-dd hh:mm:ss', time)} 起每隔 ${formatTime(interval)}`\n    }\n  }\n}\n", "import { types } from 'util'\n\nexport function noop(): any {}\n\nexport function isInteger(source: any) {\n  return typeof source === 'number' && Math.floor(source) === source\n}\n\nexport async function sleep(ms: number): Promise<void> {\n  return new Promise(resolve => setTimeout(resolve, ms))\n}\n\nexport function enumKeys<T extends string>(data: Record<T, string | number>) {\n  return Object.values(data).filter(value => typeof value === 'string') as T[]\n}\n\nexport function defineEnumProperty<T extends object>(object: T, key: keyof T, value: T[keyof T]) {\n  object[key] = value\n  object[value as any] = key\n}\n\nconst primitives = ['number', 'string', 'bigint', 'boolean', 'symbol']\n\nexport function clone<T extends unknown>(source: T): T {\n  // primitive types\n  if (primitives.includes(typeof source)) return source\n\n  // null & undefined\n  if (!source) return source\n\n  // array\n  if (Array.isArray(source)) return source.map(clone) as any\n\n  // date\n  if (types.isDate(source)) return new Date(source.valueOf()) as any\n\n  // regexp\n  if (types.isRegExp(source)) return new RegExp(source.source, source.flags) as any\n\n  // fallback\n  const entries = Object.entries(source).map(([key, value]) => [key, clone(value)])\n  return Object.fromEntries(entries)\n}\n\nexport function merge<T extends object>(head: T, base: T): T {\n  Object.entries(base).forEach(([key, value]) => {\n    if (typeof head[key] === 'undefined') return head[key] = base[key]\n    if (typeof value === 'object' && typeof head[key] === 'object') {\n      head[key] = merge(head[key], value)\n    }\n  })\n  return head\n}\n\nexport function pick<T, K extends keyof T>(source: T, keys?: Iterable<K>) {\n  if (!keys) return { ...source }\n  const result = {} as Pick<T, K>\n  for (const key of keys) {\n    result[key] = source[key]\n  }\n  return result\n}\n\nexport function omit<T, K extends keyof T>(source: T, keys?: Iterable<K>) {\n  if (!keys) return { ...source }\n  const result = { ...source } as Omit<T, K>\n  for (const key of keys) {\n    Reflect.deleteProperty(result, key)\n  }\n  return result\n}\n\nexport function defineProperty<T, K extends keyof T>(object: T, key: K, value: T[K]): void\nexport function defineProperty<T, K extends keyof any>(object: T, key: K, value: any): void\nexport function defineProperty<T, K extends keyof any>(object: T, key: K, value: any) {\n  Object.defineProperty(object, key, { writable: true, value })\n}\n\nexport function assertProperty<O, K extends keyof O>(config: O, key: K) {\n  if (!config[key]) throw new Error(`missing configuration \"${key}\"`)\n  return config[key]\n}\n\nexport function coerce(val: any) {\n  const { stack } = val instanceof Error ? val : new Error(val as any)\n  return stack\n}\n\nexport function makeArray<T>(source: T | T[]) {\n  return Array.isArray(source) ? source\n    : source === null || source === undefined ? []\n      : [source]\n}\n\nexport function renameProperty<O extends object, K extends keyof O, T extends string>(config: O, key: K, oldKey: T) {\n  config[key] = Reflect.get(config, oldKey)\n  Reflect.deleteProperty(config, oldKey)\n}\n\nexport type Get<T extends {}, K> = K extends keyof T ? T[K] : never\nexport type Extract<S, T, U = S> = S extends T ? U : never\nexport type MaybeArray<T> = [T] extends [unknown[]] ? T : T | T[]\nexport type Promisify<T> = [T] extends [Promise<unknown>] ? T : Promise<T>\nexport type Awaitable<T> = [T] extends [Promise<unknown>] ? T : T | Promise<T>\n", "import { types } from 'util'\nimport { noop, defineProperty } from './misc'\nimport { Logger } from './logger'\n\nconst logger = new Logger('observer')\nconst staticTypes = ['number', 'string', 'bigint', 'boolean', 'symbol', 'function']\nconst builtinClasses = ['Date', 'RegExp', 'Set', 'Map', 'WeakSet', 'WeakMap', 'Array']\n\nfunction observeProperty(value: any, proxy: any, key: any, label: string, update: any) {\n  if (types.isDate(value)) {\n    return proxy[key] = observeDate(value, update)\n  } else if (Array.isArray(value)) {\n    return proxy[key] = observeArray(value, label, update)\n  } else {\n    return proxy[key] = observeObject(value, label, update)\n  }\n}\n\nfunction observeObject<T extends object>(target: T, label: string, update?: () => void): T {\n  if (!target['__proxyGetters__']) {\n    Object.defineProperty(target, '__proxyGetters__', { value: {} })\n  }\n\n  const diff = {}\n  const getters = target['__proxyGetters__']\n  if (!update) defineProperty(target, '_diff', diff)\n\n  const proxy = new Proxy(target as Observed<T>, {\n    get(target, key) {\n      if (key in getters) return getters[key]\n      const value = target[key]\n      if (!value || staticTypes.includes(typeof value) || typeof key === 'string' && key.startsWith('_')) return value\n      const _update = update || (() => {\n        const hasKey = key in diff\n        diff[key] = getters[key]\n        if (!hasKey && label) {\n          logger.debug(`[diff] ${label}: ${String(key)} (deep)`)\n        }\n      })\n      return observeProperty(value, getters, key, label, _update)\n    },\n    set(target, key, value) {\n      if (target[key] !== value && (typeof key !== 'string' || !key.startsWith('_'))) {\n        if (update) {\n          update()\n        } else {\n          const hasKey = key in diff\n          diff[key] = value\n          delete getters[key]\n          if (!hasKey && label) {\n            logger.debug(`[diff] ${label}: ${String(key)}`)\n          }\n        }\n      }\n      return Reflect.set(target, key, value)\n    },\n    deleteProperty(target, key) {\n      if (update) {\n        update()\n      } else {\n        delete diff[key]\n      }\n      return Reflect.deleteProperty(target, key)\n    },\n  })\n\n  return proxy\n}\n\nconst arrayProxyMethods = ['pop', 'shift', 'splice', 'sort']\n\nfunction observeArray<T>(target: T[], label: string, update: () => void) {\n  const proxy: Record<number, T> = {}\n\n  for (const method of arrayProxyMethods) {\n    defineProperty(target, method, function (...args: any[]) {\n      update()\n      return Array.prototype[method].apply(this, args)\n    })\n  }\n\n  return new Proxy(target, {\n    get(target, key) {\n      if (key in proxy) return proxy[key]\n      const value = target[key]\n      if (!value || staticTypes.includes(typeof value) || typeof key === 'symbol' || isNaN(key as any)) return value\n      return observeProperty(value, proxy, key, label, update)\n    },\n    set(target, key, value) {\n      if (typeof key !== 'symbol' && !isNaN(key as any) && target[key] !== value) update()\n      return Reflect.set(target, key, value)\n    },\n  })\n}\n\nfunction observeDate(target: Date, update: () => void) {\n  for (const method of Object.getOwnPropertyNames(Date.prototype)) {\n    if (method === 'valueOf') continue\n    defineProperty(target, method, function (...args: any[]) {\n      const oldValue = target.valueOf()\n      const result = Date.prototype[method].apply(this, args)\n      if (target.valueOf() !== oldValue) update()\n      return result\n    })\n  }\n  return target\n}\n\nexport type Observed<T, R = any> = T & {\n  _diff: Partial<T>\n  _update: () => R\n  _merge: (value: Partial<T>) => Observed<T, R>\n}\n\ntype UpdateFunction<T, R> = (diff: Partial<T>) => R\n\nexport function observe<T extends object>(target: T, label?: string | number): Observed<T, void>\nexport function observe<T extends object, R>(target: T, update: UpdateFunction<T, R>, label?: string | number): Observed<T, R>\nexport function observe<T extends object, R>(target: T, ...args: [(string | number)?] | [UpdateFunction<T, R>, (string | number)?]) {\n  if (staticTypes.includes(typeof target)) {\n    throw new Error(`cannot observe immutable type \"${typeof target}\"`)\n  } else if (!target) {\n    throw new Error('cannot observe null or undefined')\n  }\n\n  const type = Object.prototype.toString.call(target).slice(8, -1)\n  if (builtinClasses.includes(type)) {\n    throw new Error(`cannot observe instance of type \"${type}\"`)\n  }\n\n  let label = '', update: UpdateFunction<T, R> = noop\n  if (typeof args[0] === 'function') update = args.shift() as any\n  if (typeof args[0] === 'string') label = args[0]\n\n  const observer = observeObject(target, label, null) as Observed<T>\n\n  defineProperty(observer, '_update', function _update(this: Observed<T>) {\n    const diff = { ...this._diff }\n    const fields = Object.keys(diff)\n    if (fields.length) {\n      if (label) logger.debug(`[update] ${label}: ${fields.join(', ')}`)\n      for (const key in this._diff) {\n        delete this._diff[key]\n      }\n      return update(diff)\n    }\n  })\n\n  defineProperty(observer, '_merge', function _merge(this: Observed<T>, value: Partial<T>) {\n    for (const key in value) {\n      if (key in this._diff) {\n        throw new Error(`unresolved diff key \"${key}\"`)\n      }\n      target[key] = value[key]\n      delete this['__proxyGetters__'][key]\n    }\n    return this\n  })\n\n  return observer\n}\n", "import { randomFillSync } from 'crypto'\n\n/**\n * random operations\n */\nexport class Random {\n  constructor(private value = Math.random()) {}\n\n  bool(probability: number) {\n    if (probability >= 1) return true\n    if (probability <= 0) return false\n    return this.value < probability\n  }\n\n  /**\n   * random real\n   * @param start start number\n   * @param end end number\n   * @returns a random real in the interval [start, end)\n   */\n  real(end: number): number\n  real(start: number, end: number): number\n  real(...args: [number, number?]): number {\n    const start = args.length > 1 ? args[0] : 0\n    const end = args[args.length - 1]\n    return this.value * (end - start) + start\n  }\n\n  /**\n   * random integer\n   * @param start start number\n   * @param end end number\n   * @returns a random integer in the interval [start, end)\n   */\n  int(end: number): number\n  int(start: number, end: number): number\n  int(...args: [number, number?]): number {\n    return Math.floor(this.real(...args))\n  }\n\n  pick<T>(source: readonly T[]) {\n    return source[Math.floor(this.value * source.length)]\n  }\n\n  splice<T>(source: T[]) {\n    return source.splice(Math.floor(this.value * source.length), 1)[0]\n  }\n\n  weightedPick<T extends string>(weights: Readonly<Record<T, number>>): T {\n    const total = Object.entries(weights).reduce((prev, [, curr]) => prev + (curr as number), 0)\n    const pointer = this.value * total\n    let counter = 0\n    for (const key in weights) {\n      counter += weights[key]\n      if (pointer < counter) return key\n    }\n  }\n}\n\nconst hex: string[] = []\n\nfor (let i = 0; i < 256; ++i) {\n  hex.push((i + 0x100).toString(16).substr(1))\n}\n\nexport namespace Random {\n  export function uuid() {\n    const arr = randomFillSync(new Uint8Array(16))\n    arr[6] = arr[6] & 0x0f | 0x40\n    arr[8] = arr[8] & 0x3f | 0x80\n    return hex[arr[0]] + hex[arr[1]] + hex[arr[2]] + hex[arr[3]]\n      + '-' + hex[arr[4]] + hex[arr[5]] + '-' + hex[arr[6]] + hex[arr[7]]\n      + '-' + hex[arr[8]] + hex[arr[9]] + '-' + hex[arr[10]] + hex[arr[11]]\n      + hex[arr[12]] + hex[arr[13]] + hex[arr[14]] + hex[arr[15]]\n  }\n\n  export function digits(length: number) {\n    let result = ''\n    for (let i = 0; i < length; ++i) {\n      result += Math.floor(Math.random() * 10)\n    }\n    return result\n  }\n\n  /**\n   * random real\n   * @param start start number\n   * @param end end number\n   * @returns a random real in the interval [start, end)\n   */\n  export function real(end: number): number\n  export function real(start: number, end: number): number\n  export function real(...args: [number, number?]): number {\n    return new Random().real(...args)\n  }\n\n  /**\n   * random integer\n   * @param start start number\n   * @param end end number\n   * @returns a random integer in the interval [start, end)\n   */\n  export function int(end: number): number\n  export function int(start: number, end: number): number\n  export function int(...args: [number, number?]): number {\n    return new Random().int(...args)\n  }\n\n  export function pick<T>(source: readonly T[]) {\n    return new Random().pick(source)\n  }\n\n  export function shuffle<T>(source: readonly T[]) {\n    const clone = source.slice()\n    const result: T[] = []\n    for (let i = source.length; i > 0; --i) {\n      result.push(new Random().splice(clone))\n    }\n    return result\n  }\n\n  export function multiPick<T>(source: T[], count: number) {\n    source = source.slice()\n    const result: T[] = []\n    const length = Math.min(source.length, count)\n    for (let i = 0; i < length; i += 1) {\n      const index = Math.floor(Math.random() * source.length)\n      const [item] = source.splice(index, 1)\n      result.push(item)\n    }\n    return result\n  }\n\n  export function weightedPick<T extends string>(weights: Readonly<Record<T, number>>): T {\n    return new Random().weightedPick(weights)\n  }\n\n  export function bool(probability: number) {\n    return new Random().bool(probability)\n  }\n}\n", "import { types } from 'util'\nimport { Awaitable } from './misc'\n\nexport interface segment {\n  type: string\n  data: segment.Data\n}\n\nexport function segment(type: string, data: segment.Data = {}) {\n  if (type === 'text') return segment.escape(String(data.content))\n  let output = '[CQ:' + type\n  for (const key in data) {\n    if (data[key]) output += `,${key}=${segment.escape(data[key], true)}`\n  }\n  return output + ']'\n}\n\ntype primitive = string | number | boolean\n\nexport namespace segment {\n  export type Chain = segment.Parsed[]\n  export type Data = Record<string, primitive>\n  export type Transformer = string | ((data: Record<string, string>, index: number, chain: Chain) => string)\n  export type AsyncTransformer = string | ((data: Record<string, string>, index: number, chain: Chain) => Awaitable<string>)\n\n  export interface Parsed extends segment {\n    data: Record<string, string>\n    capture?: RegExpExecArray\n  }\n\n  export function escape(source: any, inline = false) {\n    const result = String(source)\n      .replace(/&/g, '&amp;')\n      .replace(/\\[/g, '&#91;')\n      .replace(/\\]/g, '&#93;')\n    return inline\n      ? result.replace(/,/g, '&#44;').replace(/(\\ud83c[\\udf00-\\udfff])|(\\ud83d[\\udc00-\\ude4f\\ude80-\\udeff])|[\\u2600-\\u2B55]/g, ' ')\n      : result\n  }\n\n  export function unescape(source: string) {\n    return String(source)\n      .replace(/&#91;/g, '[')\n      .replace(/&#93;/g, ']')\n      .replace(/&#44;/g, ',')\n      .replace(/&amp;/g, '&')\n  }\n\n  export function join(chain: segment[]) {\n    return chain.map(node => segment(node.type, node.data)).join('')\n  }\n\n  export interface FindOptions {\n    type?: string\n    caret?: boolean\n  }\n\n  export function from(source: string, options: FindOptions = {}): segment.Parsed {\n    let regExpSource = `\\\\[CQ:(${options.type || '\\\\w+'})((,\\\\w+=[^,\\\\]]*)*)\\\\]`\n    if (options.caret) regExpSource = '^' + regExpSource\n    const capture = new RegExp(regExpSource).exec(source)\n    if (!capture) return null\n    const [, type, attrs] = capture\n    const data: Record<string, string> = {}\n    attrs && attrs.slice(1).split(',').forEach((str) => {\n      const index = str.indexOf('=')\n      data[str.slice(0, index)] = unescape(str.slice(index + 1))\n    })\n    return { type, data, capture }\n  }\n\n  export function parse(source: string) {\n    const chain: Chain = []\n    let result: segment.Parsed\n    while ((result = from(source))) {\n      const { capture } = result\n      if (capture.index) {\n        chain.push({ type: 'text', data: { content: unescape(source.slice(0, capture.index)) } })\n      }\n      chain.push(result)\n      source = source.slice(capture.index + capture[0].length)\n    }\n    if (source) chain.push({ type: 'text', data: { content: unescape(source) } })\n    return chain\n  }\n\n  export function transform(source: string, rules: Record<string, Transformer>, dropOthers = false) {\n    return parse(source).map(({ type, data, capture }, index, chain) => {\n      const transformer = rules[type]\n      return typeof transformer === 'string' ? transformer\n        : typeof transformer === 'function' ? transformer(data, index, chain)\n          : dropOthers ? '' : type === 'text' ? escape(data.content) : capture[0]\n    }).join('')\n  }\n\n  export async function transformAsync(source: string, rules: Record<string, AsyncTransformer>) {\n    const chain = segment.parse(source)\n    const cache = new Map<Parsed, string>()\n    await Promise.all(chain.map(async (node, index, chain) => {\n      const transformer = rules[node.type]\n      if (!transformer) return\n      cache.set(node, typeof transformer === 'string' ? transformer : await transformer(node.data, index, chain))\n    }))\n    return chain.map(node => cache.get(node) || segment(node.type, node.data)).join('')\n  }\n\n  export type Factory<T> = (value: T, data?: segment.Data) => string\n\n  function createFactory(type: string, key: string): Factory<primitive> {\n    return (value, data = {}) => segment(type, { ...data, [key]: value })\n  }\n\n  function createAssetFactory(type: string): Factory<string | Buffer | ArrayBuffer> {\n    return (value, data = {}) => {\n      if (Buffer.isBuffer(value)) {\n        value = 'base64://' + value.toString('base64')\n      } else if (types.isArrayBuffer(value)) {\n        value = 'base64://' + Buffer.from(value).toString('base64')\n      }\n      return segment(type, { ...data, url: value })\n    }\n  }\n\n  export const at = createFactory('at', 'id')\n  export const sharp = createFactory('sharp', 'id')\n  export const quote = createFactory('quote', 'id')\n  export const image = createAssetFactory('image')\n  export const video = createAssetFactory('video')\n  export const audio = createAssetFactory('audio')\n  export const file = createAssetFactory('file')\n}\n\nexport { segment as s }\n", "export function contain(array1: readonly any[], array2: readonly any[]) {\n  return array2.every(item => array1.includes(item))\n}\n\nexport function intersection<T>(array1: readonly T[], array2: readonly T[]) {\n  return array1.filter(item => array2.includes(item))\n}\n\nexport function difference<S>(array1: readonly S[], array2: readonly any[]) {\n  return array1.filter(item => !array2.includes(item))\n}\n\nexport function union<T>(array1: readonly T[], array2: readonly T[]) {\n  return Array.from(new Set([...array1, ...array2]))\n}\n\nexport function deduplicate<T>(array: readonly T[]) {\n  return [...new Set(array)]\n}\n\nexport function remove<T>(list: T[], item: T) {\n  const index = list.indexOf(item)\n  if (index >= 0) {\n    list.splice(index, 1)\n    return true\n  }\n}\n", "function deepen(modifyString: (source: string) => string) {\n  function modifyObject<T extends unknown>(source: T): T {\n    if (typeof source !== 'object' || !source) return source\n    if (Array.isArray(source)) return source.map(modifyObject) as any\n    const result = {} as any\n    for (const key in source) {\n      result[modifyString(key)] = modifyObject(source[key])\n    }\n    return result as T\n  }\n\n  return function<T> (source: T): T {\n    if (typeof source === 'string') {\n      return modifyString(source) as any\n    } else {\n      return modifyObject(source)\n    }\n  }\n}\n\nexport const camelCase = deepen(source => source.replace(/[_-][a-z]/g, str => str.slice(1).toUpperCase()))\nexport const paramCase = deepen(source => source.replace(/_/g, '-').replace(/(?<!^)[A-Z]/g, str => '-' + str.toLowerCase()))\nexport const snakeCase = deepen(source => source.replace(/-/g, '_').replace(/(?<!^)[A-Z]/g, str => '_' + str.toLowerCase()))\n\nexport const camelize = camelCase\nexport const hyphenate = paramCase\n\nexport function capitalize(source: string) {\n  return source.charAt(0).toUpperCase() + source.slice(1)\n}\n\n// eslint-disable-next-line no-new-func\nexport const interpolate = new Function('template', 'context', `\n  return template.replace(/\\\\{\\\\{[\\\\s\\\\S]+?\\\\}\\\\}/g, (sub) => {\n    const expr = sub.substring(2, sub.length - 2)\n    try {\n      with (context) {\n        return eval(expr)\n      }\n    } catch {\n      return ''\n    }\n  })\n`) as ((template: string, context: object) => string)\n\nexport function escapeRegExp(source: string) {\n  return source\n    .replace(/[|\\\\{}()[\\]^$+*?.]/g, '\\\\$&')\n    .replace(/-/g, '\\\\x2d')\n}\n\nexport function trimSlash(source: string) {\n  return source.replace(/\\/$/, '')\n}\n\nexport function sanitize(source: string) {\n  if (!source.startsWith('/')) source = '/' + source\n  return trimSlash(source)\n}\n\nexport function template(path: string | string[], ...params: any[]) {\n  if (!Array.isArray(path)) path = [path]\n  for (const item of path) {\n    const source = template.get(item)\n    if (typeof source === 'string') {\n      return template.format(source, ...params)\n    }\n  }\n  return path[0]\n}\n\nfunction deepAssign(head: any, base: any): any {\n  Object.entries(base).forEach(([key, value]) => {\n    if (typeof value === 'object' && typeof head[key] === 'object') {\n      head[key] = deepAssign(head[key], value)\n    } else {\n      head[key] = base[key]\n    }\n  })\n  return head\n}\n\nexport namespace template {\n  export type Node = string | Store\n\n  export interface Store {\n    [K: string]: Node\n  }\n\n  const store: Store = {}\n\n  export function set(path: string, value: Node) {\n    const seg = path.split('.')\n    let node: Node = store\n    while (seg.length > 1) {\n      node = node[seg.shift()] ||= {}\n    }\n    deepAssign(node, { [seg[0]]: value })\n  }\n\n  export function get(path: string) {\n    const seg = path.split('.')\n    let node: Node = store\n    do {\n      node = node[seg.shift()]\n    } while (seg.length && node)\n    if (typeof node === 'string') return node\n  }\n\n  export function format(source: string, ...params: any[]) {\n    if (params[0] && typeof params[0] === 'object') {\n      source = interpolate(source, params[0])\n    }\n    let result = ''\n    let cap: RegExpExecArray\n    // eslint-disable-next-line no-cond-assign\n    while (cap = /\\{(\\w+)\\}/.exec(source)) {\n      result += source.slice(0, cap.index) + (cap[1] in params ? params[cap[1]] : '')\n      source = source.slice(cap.index + cap[0].length)\n    }\n    return result + source\n  }\n\n  export function quote(content: any) {\n    return get('basic.left-quote') + content + get('basic.right-quote')\n  }\n\n  export function brace(items: any[]) {\n    if (!items.length) return ''\n    return get('basic.left-brace') + items.join(get('basic.comma')) + get('basic.right-brace')\n  }\n}\n\nexport { template as t }\n\n/* eslint-disable quote-props */\ntemplate.set('basic', {\n  'left-brace': '（',\n  'right-brace': '）',\n  'left-quote': '“',\n  'right-quote': '”',\n  'comma': '，',\n  'and': '和',\n  'or': '或',\n})\n"],
  "mappings": "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",
  "names": []
}

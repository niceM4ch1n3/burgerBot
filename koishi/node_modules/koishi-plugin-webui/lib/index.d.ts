/// <reference types="ws" />
import { Context, Channel, Platform, Plugin, Assets, Bot, Adapter, App, User } from 'koishi-core';
import WebSocket from 'ws';
export type StatRecord = Record<string, number>;
export interface Synchronizer {
    groups: StatRecord;
    daily: Record<Synchronizer.DailyField, StatRecord>;
    hourly: Record<Synchronizer.HourlyField, number>;
    longterm: Record<Synchronizer.LongtermField, number>;
    addDaily(field: Synchronizer.DailyField, key: string | number): void;
    upload(date: Date): Promise<void>;
    download(): Promise<Synchronizer.Data>;
}
export namespace Synchronizer {
    type DailyField = typeof dailyFields[number];
    const dailyFields: readonly ["command", "dialogue", "botSend", "botReceive", "group"];
    type HourlyField = typeof hourlyFields[number];
    const hourlyFields: readonly ["total", "group", "private", "command", "dialogue"];
    type LongtermField = typeof longtermFields[number];
    const longtermFields: readonly ["message"];
    interface Data {
        extension?: Statistics.Payload;
        groups: Pick<Channel, 'id' | 'name' | 'assignee'>[];
        daily: Record<DailyField, StatRecord>[];
        hourly: ({
            time: Date;
        } & Record<HourlyField, number>)[];
        longterm: ({
            time: Date;
        } & Record<LongtermField, number>)[];
    }
}
export const RECENT_LENGTH = 5;
export function average(stats: {}[]): StatRecord;
interface GroupData {
    name: string;
    platform: Platform;
    assignee: string;
    value: number;
    last: number;
}
declare class Statistics {
    private ctx;
    config: Statistics.Config;
    sync: Synchronizer;
    lastUpdate: Date;
    updateHour: number;
    callbacks: Statistics.Extension[];
    cachedDate: number;
    cachedData: Promise<Statistics.Payload>;
    average: typeof average;
    constructor(ctx: Context, config?: Statistics.Config);
    upload(forced?: boolean): Promise<void>;
    extend(callback: Statistics.Extension): void;
    private extendBasic;
    private extendGroup;
    download(): Promise<Statistics.Payload>;
    get(): Promise<Statistics.Payload>;
}
declare namespace Statistics {
    interface Payload {
        history: StatRecord;
        commands: StatRecord;
        hours: StatRecord[];
        groups: GroupData[];
        botSend: StatRecord;
        botReceive: StatRecord;
    }
    interface Config {
        statsInternal?: number;
    }
    type Extension = (payload: Payload, data: Synchronizer.Data) => Promise<void>;
}
interface PackageBase {
    name: string;
    version: string;
    description: string;
}
declare class Awesome {
    private ctx;
    config: Awesome.Config;
    cached: Promise<Awesome.PackageData[]>;
    constructor(ctx: Context, config: Awesome.Config);
    get(forced?: boolean): Promise<Awesome.PackageData[]>;
    private getForced;
    install(name: string): Promise<void>;
}
declare namespace Awesome {
    interface Config {
        apiPath?: string;
    }
    interface PackageMeta extends PackageBase {
        isWorkspace: boolean;
        isInstalled: boolean;
    }
    interface PackageData extends PackageBase {
        local?: PackageMeta;
        official: boolean;
        size: number;
        score: {
            final: number;
            quality: number;
            popularity: number;
            maintenance: number;
        };
    }
}
declare class Registry {
    private ctx;
    config: Registry.Config;
    cached: Promise<Registry.PluginData[]>;
    promise: Promise<void>;
    static readonly placeholder: unique symbol;
    static readonly webExtension: unique symbol;
    constructor(ctx: Context, config: Registry.Config);
    update: () => void;
    get(forced?: boolean): Promise<Registry.PluginData[]>;
    private getForced;
    switch(id: string): Promise<void>;
    traverse: (plugin: Plugin) => Registry.PluginData;
}
declare namespace Registry {
    interface Config {
    }
    interface PluginData extends Plugin.Meta {
        id: string;
        children: PluginData[];
        complexity: number;
        webExtension: boolean;
    }
}
declare class Meta {
    private ctx;
    config: Meta.Config;
    timestamp: number;
    cached: Promise<Meta.Payload>;
    callbacks: Meta.Extension[];
    constructor(ctx: Context, config: Meta.Config);
    get(): Promise<Meta.Payload>;
    extend(callback: Meta.Extension): void;
}
declare namespace Meta {
    interface Config {
        metaInterval?: number;
    }
    interface Stats {
        allUsers: number;
        activeUsers: number;
        allGroups: number;
        activeGroups: number;
        storageSize: number;
    }
    interface Payload extends Stats, Assets.Stats {
    }
    type Extension = () => Promise<Partial<Payload>>;
}
export type LoadRate = [app: number, total: number];
export type MessageRate = [send: number, receive: number];
export interface BotData {
    username: string;
    selfId: string;
    platform: Platform;
    code: Bot.Status;
    currentRate: MessageRate;
}
export function BotData(bot: Bot): Promise<BotData>;
declare class Profile {
    private ctx;
    cached: Profile.Payload;
    constructor(ctx: Context, config: Profile.Config);
    get(forced?: boolean): Promise<Profile.Payload>;
    static initBot(bot: Bot): void;
    private apply;
}
declare namespace Profile {
    interface Config {
        tickInterval?: number;
    }
    interface Payload {
        bots: BotData[];
        memory: LoadRate;
        cpu: LoadRate;
    }
}
export { Awesome, Registry, Meta, Profile, Statistics };
interface BaseConfig {
    title?: string;
    devMode?: boolean;
    uiPath?: string;
}
export interface Config extends BaseConfig, Profile.Config, Meta.Config, Registry.Config, Statistics.Config {
    title?: string;
    selfUrl?: string;
    apiPath?: string;
    expiration?: number;
}
export interface ClientConfig extends Required<BaseConfig> {
    version: string;
    database: boolean;
    endpoint: string;
    extensions: string[];
}
export class SocketHandle {
    readonly webui: WebServer;
    socket: WebSocket;
    readonly app: App;
    readonly id: string;
    authority: number;
    constructor(webui: WebServer, socket: WebSocket);
    send(type: string, body?: any): void;
    validate<T extends User.Field>(id: string, token: string, fields?: T[]): Promise<void | Pick<User, "id" | "authority" | "token" | "expire" | T>>;
}
export class WebServer extends Adapter {
    private ctx;
    config: Config;
    readonly root: string;
    readonly sources: WebServer.Sources;
    readonly global: ClientConfig;
    readonly entries: Record<string, string>;
    readonly handles: Record<string, SocketHandle>;
    readonly states: Record<string, [string, number, SocketHandle]>;
    private vite;
    private readonly server;
    private readonly [Context.current];
    constructor(ctx: Context, config: Config);
    broadcast(type: string, body: any): void;
    private triggerReload;
    addEntry(filename: string): void;
    addListener(event: string, listener: WebServer.Listener): void;
    start(): Promise<void>;
    stop(): void;
    private onConnection;
    private serveAssets;
    private transformHtml;
    private createVite;
}
export namespace WebServer {
    interface DataSource<T = any> {
        get(forced?: boolean): Promise<T>;
    }
    interface Sources extends Record<string, DataSource> {
        meta: Meta;
        awesome: Awesome;
        stats: Statistics;
        profile: Profile;
        registry: Registry;
    }
    type Listener = (this: SocketHandle, payload: any) => Promise<void>;
    const listeners: Record<string, Listener>;
}
declare module 'koishi-plugin-mongo' {
    interface Tables {
        'plugin-status': any;
    }
}
export type Activity = Record<number, number>;
declare module 'koishi-core' {
    namespace Context {
        interface Delegates {
            webui: WebServer;
        }
    }
    interface Database {
        getStats(): Promise<Meta.Stats>;
        createSynchronizer(): Synchronizer;
    }
    interface Session {
        _sendType?: 'command' | 'dialogue';
    }
    interface Bot {
        messageSent: number[];
        messageReceived: number[];
    }
    interface EventMap {
        'status/tick'(): void;
    }
    interface User {
        lastCall: Date;
        password: string;
        token: string;
        expire: number;
    }
    interface Channel {
        name: string;
        activity: Activity;
    }
    namespace Plugin {
        interface Packages {
            'koishi-plugin-webui': typeof import(".");
        }
    }
}
export const name = "webui";
export function apply(ctx: Context, config?: Config): void;export default Profile;

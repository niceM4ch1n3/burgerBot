var __create = Object.create;
var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __markAsModule = (target) => __defProp(target, "__esModule", { value: true });
var __export = (target, all) => {
  __markAsModule(target);
  for (var name2 in all)
    __defProp(target, name2, { get: all[name2], enumerable: true });
};
var __reExport = (target, module2, desc) => {
  if (module2 && typeof module2 === "object" || typeof module2 === "function") {
    for (let key of __getOwnPropNames(module2))
      if (!__hasOwnProp.call(target, key) && key !== "default")
        __defProp(target, key, { get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable });
  }
  return target;
};
var __toModule = (module2) => {
  return __reExport(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, "default", module2 && module2.__esModule && "default" in module2 ? { get: () => module2.default, enumerable: true } : { value: module2, enumerable: true })), module2);
};

// packages/plugin-webui/src/index.ts
__export(exports, {
  Awesome: () => awesome_default,
  Meta: () => meta_default,
  Profile: () => profile_default,
  Registry: () => registry_default,
  SocketHandle: () => SocketHandle,
  Statistics: () => stats_default,
  WebServer: () => WebServer,
  apply: () => apply,
  name: () => name
});
var import_koishi_core7 = __toModule(require("koishi-core"));
var import_koishi_utils = __toModule(require("koishi-utils"));

// packages/plugin-webui/src/server.ts
var import_koishi_core4 = __toModule(require("koishi-core"));
var import_path2 = __toModule(require("path"));
var import_fs2 = __toModule(require("fs"));

// packages/plugin-webui/src/payload/awesome.ts
var import_koishi_core = __toModule(require("koishi-core"));
var import_path = __toModule(require("path"));
var import_fs = __toModule(require("fs"));
var import_child_process = __toModule(require("child_process"));
var import_semver = __toModule(require("semver"));
var import_axios = __toModule(require("axios"));
var officialPlugins = [
  "adventure",
  "assets",
  "chat",
  "chess",
  "common",
  "dice",
  "eval",
  "github",
  "image-search",
  "mongo",
  "mysql",
  "puppeteer",
  "schedule",
  "teach",
  "tools",
  "webui"
];
var cwd = process.cwd();
function execute(bin, args = [], stdio = "inherit") {
  const child = (0, import_child_process.spawn)(bin + (process.platform === "win32" ? ".cmd" : ""), args, { stdio });
  return new Promise((resolve3) => {
    child.on("close", resolve3);
  });
}
var _managerPromise;
async function getManager() {
  if ((0, import_fs.existsSync)((0, import_path.resolve)(cwd, "yarn.lock")))
    return "yarn";
  if ((0, import_fs.existsSync)((0, import_path.resolve)(cwd, "package-lock.json")))
    return "npm";
  if (!await execute("yarn", ["--version"], "ignore"))
    return "yarn";
  return "npm";
}
var installArgs = {
  yarn: ["add"],
  npm: ["install", "--loglevel", "error"]
};
var Awesome = class {
  constructor(ctx, config) {
    this.ctx = ctx;
    this.config = config;
    ctx.router.get(config.apiPath + "/package(/.+)+", async (ctx2) => {
      const name2 = ctx2.path.slice(config.apiPath.length + 9);
      const { data } = await import_axios.default.get(`https://registry.npmjs.org/${name2}`);
      ctx2.body = data;
      ctx2.set("Access-Control-Allow-Origin", "*");
    });
  }
  async get(forced = false) {
    if (this.cached && !forced)
      return this.cached;
    return this.cached = this.getForced();
  }
  async getForced() {
    const _loadDep = async (filename, isInstalled) => {
      do {
        filename = (0, import_path.dirname)(filename);
        const files = await import_fs.promises.readdir(filename);
        if (files.includes("package.json"))
          break;
      } while (true);
      const data2 = JSON.parse(await import_fs.promises.readFile(filename + "/package.json", "utf8"));
      if (data2.private)
        return null;
      const isWorkspace = !filename.includes("node_modules");
      return __spreadValues({ isWorkspace, isInstalled }, (0, import_koishi_core.pick)(data2, ["name", "version", "description"]));
    };
    const loadCache = {};
    const loadDep = (filename, isInstalled) => {
      return loadCache[filename] || (loadCache[filename] = _loadDep(filename, isInstalled));
    };
    const [{ data }] = await Promise.all([
      import_axios.default.get("https://api.npms.io/v2/search?q=koishi-plugin+not:deprecated&size=250"),
      Promise.all(Object.keys(require.cache).map((filename) => {
        const { exports } = require.cache[filename];
        if (this.ctx.app.registry.has(exports))
          return loadDep(filename, true);
      }))
    ]);
    const loadExternal = (name2) => {
      try {
        const filename = require.resolve(name2);
        return loadDep(filename, false);
      } catch {
      }
    };
    return Promise.all(data.results.map(async (item) => {
      const { name: name2, version: version2 } = item.package;
      const official = officialPlugins.includes(name2.slice(14));
      const [local, { data: data2 }] = await Promise.all([
        loadExternal(name2),
        import_axios.default.get(`https://registry.npmjs.org/${name2}`)
      ]);
      const { dependencies = {}, peerDependencies = {}, dist } = data2.versions[version2];
      const core = __spreadValues(__spreadValues({}, dependencies), peerDependencies)["koishi-core"];
      if (!core || !(0, import_semver.satisfies)(import_koishi_core.version, core))
        return;
      return __spreadProps(__spreadValues({}, item.package), {
        local,
        official,
        size: dist.unpackedSize,
        score: __spreadValues({
          final: item.score.final
        }, item.score.detail)
      });
    })).then((data2) => data2.filter(Boolean));
  }
  async install(name2) {
    const kind = await (_managerPromise || (_managerPromise = getManager()));
    const args = [...installArgs[kind], name2];
    await execute(kind, args);
    this.ctx.webui.broadcast("awesome", await this.get(true));
  }
};
var awesome_default = Awesome;

// packages/plugin-webui/src/payload/registry.ts
function debounce(callback, ms) {
  let timer;
  return function() {
    if (timer)
      clearTimeout(timer);
    timer = setTimeout(callback, ms);
  };
}
var _Registry = class {
  constructor(ctx, config) {
    this.ctx = ctx;
    this.config = config;
    this.update = debounce(async () => {
      this.ctx.webui.broadcast("registry", await this.get(true));
    }, 0);
    this.traverse = (plugin) => {
      const state = this.ctx.app.registry.get(plugin);
      let webExtension = state[_Registry.webExtension];
      let complexity = (plugin == null ? void 0 : plugin[_Registry.placeholder]) ? 0 : 1 + state.disposables.length;
      const children = [];
      state.children.forEach((plugin2) => {
        const data = this.traverse(plugin2);
        complexity += data.complexity;
        webExtension || (webExtension = data.webExtension);
        if (data.name) {
          children.push(data);
        } else {
          children.push(...data.children);
        }
      });
      const { id, name: name2, sideEffect } = state;
      children.sort((a, b) => a.name > b.name ? 1 : -1);
      return { id, name: name2, sideEffect, children, complexity, webExtension };
    };
    ctx.on("plugin-added", this.update);
    ctx.on("plugin-removed", this.update);
  }
  async get(forced = false) {
    if (this.cached && !forced)
      return this.cached;
    return this.cached = this.getForced();
  }
  async getForced() {
    return this.traverse(null).children;
  }
  async switch(id) {
    await this.promise;
    for (const [plugin, state] of this.ctx.app.registry) {
      if (id !== state.id)
        continue;
      const replacer = plugin[_Registry.placeholder] || {
        name: state.name,
        apply: Object.assign(() => {
        }, {
          [_Registry.placeholder]: state.plugin
        })
      };
      this.promise = this.ctx.dispose(plugin);
      state.context.plugin(replacer, state.config);
      break;
    }
  }
};
var Registry = _Registry;
Registry.placeholder = Symbol("webui.registry.placeholder");
Registry.webExtension = Symbol("webui.registry.web-extension");
var registry_default = Registry;

// packages/plugin-webui/src/payload/meta.ts
var import_koishi_core2 = __toModule(require("koishi-core"));
var Meta = class {
  constructor(ctx, config) {
    this.ctx = ctx;
    this.config = config;
    this.timestamp = 0;
    this.callbacks = [];
    this.extend(async () => {
      var _a;
      return (_a = ctx.assets) == null ? void 0 : _a.stats();
    });
    this.extend(async () => {
      var _a;
      return (_a = ctx.database) == null ? void 0 : _a.getStats();
    });
    ctx.all().on("command", ({ session }) => {
      session.user.lastCall = new Date();
    });
  }
  async get() {
    const now = Date.now();
    if (this.timestamp > now)
      return this.cached;
    this.timestamp = now + this.config.metaInterval;
    return this.cached = Promise.all(this.callbacks.map((cb) => cb().catch(import_koishi_core2.noop))).then((data) => Object.assign({}, ...data));
  }
  extend(callback) {
    this.timestamp = 0;
    this.callbacks.push(callback);
  }
};
var meta_default = Meta;

// packages/plugin-webui/src/payload/profile.ts
var import_os = __toModule(require("os"));
var import_systeminformation = __toModule(require("systeminformation"));
var usage = getCpuUsage();
var appRate;
var usedRate;
async function memoryRate() {
  const { total, active } = await (0, import_systeminformation.mem)();
  return [process.memoryUsage().rss / total, active / total];
}
function getCpuUsage() {
  let totalIdle = 0, totalTick = 0;
  const cpuInfo = (0, import_os.cpus)();
  const usage2 = process.cpuUsage().user;
  for (const cpu of cpuInfo) {
    for (const type in cpu.times) {
      totalTick += cpu.times[type];
    }
    totalIdle += cpu.times.idle;
  }
  return {
    app: usage2 / 1e3,
    used: (totalTick - totalIdle) / cpuInfo.length,
    total: totalTick / cpuInfo.length
  };
}
function updateCpuUsage() {
  const newUsage = getCpuUsage();
  const totalDifference = newUsage.total - usage.total;
  appRate = (newUsage.app - usage.app) / totalDifference;
  usedRate = (newUsage.used - usage.used) / totalDifference;
  usage = newUsage;
}
function accumulate(record) {
  return record.slice(1).reduce((prev, curr) => prev + curr, 0);
}
async function BotData(bot) {
  return {
    platform: bot.platform,
    selfId: bot.selfId,
    username: bot.username,
    code: await bot.getStatus(),
    currentRate: [accumulate(bot.messageSent), accumulate(bot.messageReceived)]
  };
}
var Profile = class {
  constructor(ctx, config) {
    this.ctx = ctx;
    this.apply(ctx, config);
    ctx.on("status/tick", async () => {
      this.ctx.webui.broadcast("profile", await this.get(true));
    });
  }
  async get(forced = false) {
    if (this.cached && !forced)
      return this.cached;
    const [memory, bots] = await Promise.all([
      memoryRate(),
      Promise.all(this.ctx.bots.filter((bot) => bot.platform !== "web").map(BotData))
    ]);
    const cpu = [appRate, usedRate];
    return { bots, memory, cpu };
  }
  static initBot(bot) {
    bot.messageSent = new Array(61).fill(0);
    bot.messageReceived = new Array(61).fill(0);
  }
  apply(ctx, config = {}) {
    const { tickInterval } = config;
    ctx.all().before("send", (session) => {
      session.bot.messageSent[0] += 1;
    });
    ctx.all().on("message", (session) => {
      session.bot.messageReceived[0] += 1;
    });
    ctx.on("connect", async () => {
      ctx.bots.forEach(Profile.initBot);
      ctx.setInterval(() => {
        updateCpuUsage();
        ctx.bots.forEach(({ messageSent, messageReceived }) => {
          messageSent.unshift(0);
          messageSent.splice(-1, 1);
          messageReceived.unshift(0);
          messageReceived.splice(-1, 1);
        });
        ctx.emit("status/tick");
      }, tickInterval);
    });
  }
};
var profile_default = Profile;

// packages/plugin-webui/src/payload/stats.ts
var import_koishi_core3 = __toModule(require("koishi-core"));
var Synchronizer;
(function(Synchronizer2) {
  Synchronizer2.dailyFields = [
    "command",
    "dialogue",
    "botSend",
    "botReceive",
    "group"
  ];
  Synchronizer2.hourlyFields = [
    "total",
    "group",
    "private",
    "command",
    "dialogue"
  ];
  Synchronizer2.longtermFields = [
    "message"
  ];
})(Synchronizer || (Synchronizer = {}));
var RECENT_LENGTH = 5;
function average(stats) {
  const result = {};
  stats.slice(0, RECENT_LENGTH).forEach((stat) => {
    for (const key in stat) {
      if (typeof stat[key] !== "number")
        continue;
      result[key] = (result[key] || 0) + stat[key];
    }
  });
  for (const key in result) {
    result[key] = +(result[key] / RECENT_LENGTH).toFixed(1);
  }
  return result;
}
var send = import_koishi_core3.Session.prototype.send;
import_koishi_core3.Session.prototype.send = function(...args) {
  if (args[0] && this._sendType && this.app.webui) {
    this.app.webui.sources.stats.sync.hourly[this._sendType] += 1;
  }
  return send.apply(this, args);
};
var customTag = Symbol("custom-send");
import_koishi_core3.Session.prototype.send[customTag] = send;
var Statistics = class {
  constructor(ctx, config = {}) {
    this.ctx = ctx;
    this.config = config;
    this.lastUpdate = new Date();
    this.updateHour = this.lastUpdate.getHours();
    this.callbacks = [];
    this.average = average;
    this.extendBasic = async (payload, data) => {
      payload.history = {};
      data.longterm.forEach((stat) => {
        payload.history[stat.time.toLocaleDateString("zh-CN")] = stat.message;
      });
      payload.commands = average(data.daily.map((data2) => data2.command));
      payload.botSend = average(data.daily.map((stat) => stat.botSend));
      payload.botReceive = average(data.daily.map((stat) => stat.botReceive));
      payload.hours = new Array(24).fill(0).map((_, index) => {
        return average(data.hourly.filter((s) => s.time.getHours() === index));
      });
    };
    this.extendGroup = async (payload, data) => {
      var _a;
      const groupSet = new Set();
      payload.groups = [];
      const groupMap = Object.fromEntries(data.groups.map((g) => [g.id, g]));
      const messageMap = average(data.daily.map((data2) => data2.group));
      const updateList = [];
      async function getGroupInfo(bot) {
        const { platform } = bot;
        const groups = await bot.getGroupList();
        for (const { groupId, groupName: name2 } of groups) {
          const id = `${bot.platform}:${groupId}`;
          if (!messageMap[id] || !groupMap[id] || groupSet.has(id))
            continue;
          groupSet.add(id);
          const { name: oldName, assignee } = groupMap[id];
          if (name2 !== oldName)
            updateList.push({ id, name: name2 });
          payload.groups.push({
            name: name2,
            platform,
            assignee,
            value: messageMap[id],
            last: data.daily[0].group[id] || 0
          });
        }
      }
      await Promise.all(this.ctx.bots.map((bot) => getGroupInfo(bot).catch(import_koishi_core3.noop)));
      for (const key in messageMap) {
        if (!groupSet.has(key) && groupMap[key]) {
          const { name: name2, assignee } = groupMap[key];
          const [platform] = key.split(":");
          payload.groups.push({
            platform,
            name: name2 || key,
            value: messageMap[key],
            last: data.daily[0].group[key] || 0,
            assignee: ((_a = this.ctx.bots[`${platform}:${assignee}`]) == null ? void 0 : _a.selfId) || ""
          });
        }
      }
      await this.ctx.database.update("channel", updateList);
    };
    ctx.on("exit", () => this.upload(true));
    ctx.on("delegate/database", () => {
      this.sync = ctx.database.createSynchronizer();
    });
    ctx.before("disconnect", async () => {
      if (import_koishi_core3.Session.prototype.send[customTag]) {
        import_koishi_core3.Session.prototype.send = import_koishi_core3.Session.prototype.send[customTag];
      }
      await this.upload(true);
    });
    ctx = ctx.select("database");
    ctx.before("command", ({ command, session }) => {
      var _a;
      if (((_a = command.parent) == null ? void 0 : _a.name) !== "test") {
        const [name2] = command.name.split(".", 1);
        this.sync.addDaily("command", name2);
        this.upload();
      }
      session._sendType = "command";
    });
    const updateSendStats = async (session) => {
      this.sync.hourly.total += 1;
      this.sync.hourly[session.subtype] += 1;
      this.sync.longterm.message += 1;
      this.sync.addDaily("botSend", session.sid);
      if (session.subtype === "group") {
        this.sync.addDaily("group", session.gid);
        this.sync.groups[session.gid] = (this.sync.groups[session.gid] || 0) + 1;
      }
      this.upload();
    };
    ctx.on("message", (session) => {
      this.sync.addDaily("botReceive", session.sid);
    });
    ctx.on("before-send", (session) => {
      updateSendStats(session);
    });
    this.extend(this.extendBasic);
    this.extend(this.extendGroup);
  }
  async upload(forced = false) {
    var _a;
    const date = new Date();
    const dateHour = date.getHours();
    if (forced || +date - +this.lastUpdate > this.config.statsInternal || dateHour !== this.updateHour) {
      this.lastUpdate = date;
      this.updateHour = dateHour;
      await ((_a = this.sync) == null ? void 0 : _a.upload(date));
    }
  }
  extend(callback) {
    this.callbacks.push(callback);
  }
  async download() {
    const data = await this.sync.download();
    const payload = {};
    await Promise.all(this.callbacks.map((cb) => cb(payload, data)));
    return payload;
  }
  async get() {
    if (!this.sync)
      return;
    const date = new Date();
    const dateNumber = import_koishi_core3.Time.getDateNumber(date, date.getTimezoneOffset());
    if (dateNumber !== this.cachedDate) {
      this.cachedData = this.download();
      this.cachedDate = dateNumber;
    }
    return this.cachedData;
  }
};
var stats_default = Statistics;

// packages/plugin-webui/src/server.ts
var import_ws = __toModule(require("ws"));
var logger = new import_koishi_core4.Logger("webui");
var TOKEN_TIMEOUT = import_koishi_core4.Time.minute * 10;
var SocketHandle = class {
  constructor(webui, socket) {
    this.webui = webui;
    this.socket = socket;
    this.id = import_koishi_core4.Random.uuid();
    this.app = webui.app;
  }
  send(type, body) {
    this.socket.send(JSON.stringify({ type, body }));
  }
  async validate(id, token, fields = []) {
    const user = await this.app.database.getUser("id", id, ["token", "expire", "authority", ...fields]);
    if (!user || token !== user.token || user.expire <= Date.now()) {
      return this.send("expire");
    }
    this.authority = user.authority;
    return user;
  }
};
var _WebServer = class extends import_koishi_core4.Adapter {
  constructor(ctx, config) {
    super(ctx.app);
    this.ctx = ctx;
    this.config = config;
    this.entries = {};
    this.handles = {};
    this.states = {};
    this.onConnection = (socket) => {
      const channel = new SocketHandle(this, socket);
      this.handles[channel.id] = channel;
      for (const type in this.sources) {
        this.sources[type].get().then((body) => {
          socket.send(JSON.stringify({ type, body }));
        });
      }
      socket.on("close", () => {
        delete this.handles[channel.id];
        for (const id in this.states) {
          if (this.states[id][2] === channel)
            delete this.states[id];
        }
      });
      socket.on("message", async (data) => {
        if (!this.ctx.database)
          return;
        const { type, body } = JSON.parse(data.toString());
        const method = _WebServer.listeners[type];
        if (method) {
          await method.call(channel, body);
        } else {
          logger.info(type, body);
        }
      });
    };
    const { apiPath, uiPath, devMode, selfUrl, title } = config;
    const endpoint = selfUrl + apiPath;
    this.global = { title, uiPath, endpoint, devMode, extensions: [], database: false, version: import_koishi_core4.version };
    this.root = (0, import_path2.resolve)(__dirname, "..", devMode ? "client" : "dist");
    this.server = new import_ws.default.Server({
      path: apiPath,
      server: ctx.app._httpServer
    });
    this.sources = {
      awesome: new awesome_default(ctx, config),
      profile: new profile_default(ctx, config),
      meta: new meta_default(ctx, config),
      registry: new registry_default(ctx, config),
      stats: new stats_default(ctx, config)
    };
    ctx.all().private().middleware(async (session, next) => {
      const state = this.states[session.uid];
      if (state && state[0] === session.content) {
        const user = await session.observeUser(["id", "name", "authority", "token", "expire"]);
        user.token = import_koishi_core4.Random.uuid();
        user.expire = Date.now() + config.expiration;
        return state[2].send("user", user);
      }
      return next();
    }, true);
    ctx.on("connect", () => this.start());
    ctx.before("disconnect", () => this.stop());
    ctx.on("delegate/database", () => {
      this.global.database = !!ctx.database;
    });
  }
  broadcast(type, body) {
    if (!(this == null ? void 0 : this.server.clients.size))
      return;
    const data = JSON.stringify({ type, body });
    this.server.clients.forEach((socket) => socket.send(data));
  }
  triggerReload() {
    var _a;
    this.global.extensions = Object.entries(this.entries).map(([name2, filename]) => {
      return this.config.devMode ? "/vite/@fs" + filename : `./${name2}`;
    });
    (_a = this.vite) == null ? void 0 : _a.ws.send({ type: "full-reload" });
  }
  addEntry(filename) {
    const ctx = this[import_koishi_core4.Context.current];
    let { state } = ctx;
    state[registry_default.webExtension] = true;
    while (state && !state.name)
      state = state.parent;
    const hash = Math.floor(Math.random() * 16 ** 8).toString(16).padStart(8, "0");
    const key = `${(state == null ? void 0 : state.name) || "entry"}-${hash}.js`;
    this.entries[key] = filename;
    this.triggerReload();
    ctx.before("disconnect", () => {
      delete this.entries[key];
      this.triggerReload();
    });
  }
  addListener(event, listener) {
    _WebServer.listeners[event] = listener;
  }
  async start() {
    if (this.config.devMode)
      await this.createVite();
    this.server.on("connection", this.onConnection);
    this.serveAssets();
  }
  stop() {
    this.server.close();
    for (const bot of this.bots) {
      (0, import_koishi_core4.remove)(this.app.bots, bot);
    }
  }
  serveAssets() {
    const { uiPath } = this.config;
    this.ctx.router.get(uiPath + "(/.+)*", async (ctx) => {
      if (ctx.path === uiPath && !uiPath.endsWith("/")) {
        return ctx.redirect(ctx.path + "/");
      }
      const name2 = ctx.path.slice(uiPath.length).replace(/^\/+/, "");
      const sendFile = (filename2) => {
        ctx.type = (0, import_path2.extname)(filename2);
        return ctx.body = (0, import_fs2.createReadStream)(filename2);
      };
      if (name2.startsWith("assets/")) {
        const key = name2.slice(7);
        if (this.entries[key])
          return sendFile(this.entries[key]);
      }
      const filename = (0, import_path2.resolve)(this.root, name2);
      if (!filename.startsWith(this.root) && !filename.includes("node_modules")) {
        return ctx.status = 403;
      }
      const stats = await import_fs2.promises.stat(filename).catch(import_koishi_core4.noop);
      if (stats == null ? void 0 : stats.isFile())
        return sendFile(filename);
      const ext = (0, import_path2.extname)(filename);
      if (ext && ext !== ".html")
        return ctx.status = 404;
      const template2 = await import_fs2.promises.readFile((0, import_path2.resolve)(this.root, "index.html"), "utf8");
      ctx.type = "html";
      ctx.body = await this.transformHtml(template2);
    });
  }
  async transformHtml(template2) {
    if (this.vite)
      template2 = await this.vite.transformIndexHtml(this.config.uiPath, template2);
    const headInjection = `<script>KOISHI_CONFIG = ${JSON.stringify(this.global)}<\/script>`;
    return template2.replace("</title>", "</title>" + headInjection);
  }
  async createVite() {
    const { createServer } = require("vite");
    const pluginVue = require("@vitejs/plugin-vue").default;
    this.vite = await createServer({
      root: this.root,
      base: "/vite/",
      server: { middlewareMode: true },
      plugins: [pluginVue()],
      resolve: {
        alias: {
          "~/client": this.root,
          "~/variables": this.root + "/index.scss"
        }
      }
    });
    this.ctx.router.all("/vite(/.+)+", (ctx) => new Promise((resolve3) => {
      this.vite.middlewares(ctx.req, ctx.res, resolve3);
    }));
    this.ctx.before("disconnect", () => this.vite.close());
  }
};
var WebServer = _WebServer;
import_koishi_core4.Context.current;
(function(WebServer2) {
  WebServer2.listeners = {};
  WebServer2.listeners.validate = async function({ id, token }) {
    await this.validate(id, token);
  };
  WebServer2.listeners.token = async function({ platform, userId }) {
    const user = await this.app.database.getUser(platform, userId, ["name"]);
    if (!user)
      return this.send("login", { message: "找不到此账户。" });
    const id = `${platform}:${userId}`;
    const token = import_koishi_core4.Random.uuid();
    const expire = Date.now() + TOKEN_TIMEOUT;
    const { states } = this.app.webui;
    states[id] = [token, expire, this];
    setTimeout(() => {
      var _a;
      if (((_a = states[id]) == null ? void 0 : _a[1]) > Date.now())
        delete states[id];
    }, TOKEN_TIMEOUT);
    this.send("login", { token, name: user.name });
  };
  WebServer2.listeners.password = async function({ id, token, password }) {
    const user = await this.validate(id, token, ["password"]);
    if (!user || password === user.password)
      return;
    await this.app.database.setUser("id", id, { password });
  };
  WebServer2.listeners.login = async function({ username, password }) {
    const user = await this.app.database.getUser("name", username, ["password", "authority", "id", "expire", "token"]);
    if (!user || user.password !== password) {
      return this.send("login", { message: "用户名或密码错误。" });
    }
    user.token = import_koishi_core4.Random.uuid();
    user.expire = Date.now() + this.app.webui.config.expiration;
    await this.app.database.setUser("name", username, (0, import_koishi_core4.pick)(user, ["token", "expire"]));
    this.send("user", (0, import_koishi_core4.omit)(user, ["password"]));
    this.authority = user.authority;
  };
  WebServer2.listeners.install = async function({ id, token, name: name2 }) {
    const user = await this.validate(id, token, ["name", "authority"]);
    if (!user)
      return;
    if (user.authority < 4)
      return this.send("unauthorized");
    this.webui.sources.awesome.install(name2);
  };
  WebServer2.listeners.switch = async function({ id, token, plugin }) {
    const user = await this.validate(id, token, ["name", "authority"]);
    if (!user)
      return;
    if (user.authority < 4)
      return this.send("unauthorized");
    this.webui.sources.registry.switch(plugin);
  };
})(WebServer || (WebServer = {}));

// packages/plugin-webui/src/database/mongo.ts
var import_koishi_core5 = __toModule(require("koishi-core"));
var logger2 = new import_koishi_core5.Logger("status");
var MongoSynchronizer = class {
  constructor(db) {
    this.db = db;
    this.reset();
  }
  reset() {
    this.hourly = Object.fromEntries(Synchronizer.hourlyFields.map((i) => [i, 0]));
    this.daily = {};
    this.longterm = Object.fromEntries(Synchronizer.longtermFields.map((i) => [i, 0]));
    this.groups = {};
  }
  addDaily(field, key) {
    if (!this.daily[field])
      this.daily[field] = {};
    const stat = this.daily[field];
    stat[key] = (stat[key] || 0) + 1;
  }
  async upload(date) {
    logger2.debug(this.hourly, this.daily, this.longterm, this.groups);
    const coll = this.db.collection("plugin-status");
    const _date = new Date(date);
    _date.setMinutes(0);
    _date.setSeconds(0);
    _date.setMilliseconds(0);
    await coll.updateOne({ type: "hourly", time: _date }, { $inc: this.hourly }, { upsert: true });
    _date.setHours(0);
    const $inc = {};
    for (const key in this.daily) {
      for (const subkey in this.daily[key]) {
        $inc[`${key}.${subkey}`] = this.daily[key][subkey];
      }
    }
    if (Object.keys($inc).length)
      await coll.updateOne({ type: "daily", time: _date }, { $inc }, { upsert: true });
    await coll.updateOne({ type: "longterm", time: _date }, { $inc: this.longterm }, { upsert: true });
    for (const id in this.groups) {
      await this.db.channel.updateOne({ id }, { $inc: { ["activity." + import_koishi_core5.Time.getDateNumber(date)]: this.groups[id] } });
    }
    this.reset();
    logger2.debug("stats updated");
  }
  async download() {
    const time = { $lt: new Date() };
    const coll = this.db.collection("plugin-status");
    const hourly = await coll.find({ type: "hourly", time }).sort({ time: -1 }).limit(24 * RECENT_LENGTH).toArray();
    const daily = await coll.find({ type: "daily", time }).sort({ time: -1 }).limit(RECENT_LENGTH).toArray();
    const longterm = await coll.find({ type: "longterm", time }).sort({ time: -1 }).toArray();
    const groups = await this.db.channel.find({}).project({ type: 1, pid: 1, name: 1, assignee: 1 }).map((data) => __spreadProps(__spreadValues({}, data), { id: `${data.type}:${data.pid}` })).toArray();
    return { daily, hourly, longterm, groups };
  }
};
import_koishi_core5.Database.extend("koishi-plugin-mongo", {
  async getStats() {
    const $gt = new Date(new Date().getTime() - 1e3 * 3600 * 24);
    const [allGroups, activeGroups, allUsers, activeUsers, { storageSize }] = await Promise.all([
      this.channel.countDocuments(),
      this.channel.find({ assignee: { $ne: null } }).count(),
      this.user.countDocuments(),
      this.user.find({ lastCall: { $gt } }).count(),
      this.mongo.db.stats()
    ]);
    return { allGroups, activeGroups, allUsers, activeUsers, storageSize };
  },
  createSynchronizer() {
    return new MongoSynchronizer(this);
  }
});

// packages/plugin-webui/src/database/mysql.ts
var import_koishi_core6 = __toModule(require("koishi-core"));
var logger3 = new import_koishi_core6.Logger("status");
function joinKeys(keys) {
  return keys.map((key) => `\`${key}\``).join(",");
}
var Stat = class {
  constructor(table, fields, preserve) {
    this.table = table;
    this.fields = fields;
    this.preserve = preserve;
    this.data = {};
    this.key = null;
    this.clear();
  }
  clear() {
    for (const key of this.fields) {
      this.data[key] = this.setup();
    }
  }
  synchronize(date, sqls) {
    const updates = [];
    for (const name2 in this.data) {
      if (!this.fields.includes(name2)) {
        logger3.warn(new Error(`unknown key "${name2}" in stats table "${this.table}"`));
        delete this.data[name2];
        continue;
      }
      const update = this.update(name2, this.data[name2]);
      if (update)
        updates.push(update);
    }
    if (!updates.length)
      return;
    logger3.debug(this.table, this.data);
    if (date === this.key) {
      sqls.push(`UPDATE \`${this.table}\` SET ${updates.join(", ")} WHERE \`time\` = "${date}"`);
    } else {
      this.key = date;
      sqls.push(`INSERT INTO \`${this.table}\` (\`time\`, ${joinKeys(Object.keys(this.data))}) VALUES ("${date}", ${Object.values(this.data).map(this.create).join(", ")}) ON DUPLICATE KEY UPDATE ${updates.join(", ")}`);
    }
    if (!this.preserve)
      sqls.push(`DELETE FROM \`${this.table}\` WHERE datediff("${date}", \`time\`) > 10`);
    this.clear();
  }
};
(function(Stat2) {
  class Recorded extends Stat2 {
    constructor(table, fields, preserve) {
      super(table, fields, preserve);
      import_koishi_core6.Tables.extend(table, { primary: "time" });
      import_koishi_core6.Database.extend("koishi-plugin-mysql", ({ tables, Domain }) => {
        tables[table] = Object.fromEntries(fields.map((key) => [key, new Domain.Json()]));
        tables[table].time = "datetime";
      });
    }
    setup() {
      return {};
    }
    create(value) {
      return `JSON_OBJECT(${Object.entries(value).map(([key, value2]) => `'${key}', ${value2}`).join(", ")})`;
    }
    update(name2, value) {
      const entries = Object.entries(value);
      if (!entries.length)
        return;
      return `\`${name2}\` = JSON_SET(\`${name2}\`, ${entries.map(([key, value2]) => {
        return `'$."${key}"', IFNULL(JSON_EXTRACT(\`${name2}\`, '$."${key}"'), 0) + ${value2}`;
      }).join(", ")})`;
    }
  }
  Stat2.Recorded = Recorded;
  class Numerical extends Stat2 {
    constructor(table, fields, preserve) {
      super(table, fields, preserve);
      import_koishi_core6.Tables.extend(table, { primary: "time" });
      import_koishi_core6.Database.extend("koishi-plugin-mysql", ({ tables }) => {
        tables[table] = Object.fromEntries(fields.map((key) => [key, "int unsigned"]));
        tables[table].time = "datetime";
      });
    }
    setup() {
      return 0;
    }
    create(value) {
      return "" + value;
    }
    update(key, value) {
      if (!value)
        return;
      return `\`${key}\` = \`${key}\` + ${value}`;
    }
  }
  Stat2.Numerical = Numerical;
})(Stat || (Stat = {}));
var MysqlSynchronizer = class {
  constructor(db) {
    this.db = db;
    this._daily = new Stat.Recorded("stats_daily", Synchronizer.dailyFields, false);
    this._hourly = new Stat.Numerical("stats_hourly", Synchronizer.hourlyFields, false);
    this._longterm = new Stat.Numerical("stats_longterm", Synchronizer.longtermFields, true);
    this.groups = {};
    this.daily = this._daily.data;
    this.hourly = this._hourly.data;
    this.longterm = this._longterm.data;
  }
  addDaily(field, key) {
    const stat = this._daily.data[field];
    stat[key] = (stat[key] || 0) + 1;
  }
  async upload(date) {
    const dateString = date.toLocaleDateString("zh-CN");
    const hourString = `${dateString}-${date.getHours()}:00`;
    const sqls = [];
    this._hourly.synchronize(hourString, sqls);
    this._daily.synchronize(dateString, sqls);
    this._longterm.synchronize(dateString, sqls);
    for (const id in this.groups) {
      const update = Stat.Recorded.prototype.update("activity", { [import_koishi_core6.Time.getDateNumber(date)]: this.groups[id] });
      sqls.push(`UPDATE \`channel\` SET ${update} WHERE \`id\` = '${id}'`);
      delete this.groups[id];
    }
    if (!sqls.length)
      return;
    logger3.debug("stats updated");
    await this.db.query(sqls);
  }
  async download() {
    const [daily, hourly, longterm, groups] = await this.db.query([
      "SELECT * FROM `stats_daily` WHERE `time` < CURRENT_TIMESTAMP ORDER BY `time` DESC LIMIT ?",
      "SELECT * FROM `stats_hourly` WHERE `time` < CURRENT_TIMESTAMP ORDER BY `time` DESC LIMIT ?",
      "SELECT * FROM `stats_longterm` WHERE `time` < CURRENT_TIMESTAMP ORDER BY `time` DESC",
      "SELECT `id`, `name`, `assignee` FROM `channel`"
    ], [RECENT_LENGTH, 24 * RECENT_LENGTH]);
    return { daily, hourly, longterm, groups };
  }
};
import_koishi_core6.Database.extend("koishi-plugin-mysql", {
  async getStats() {
    const [[{ activeUsers }], [{ allUsers }], [{ activeGroups }], [{ allGroups }], [{ storageSize }]] = await this.query([
      "SELECT COUNT(*) as activeUsers FROM `user` WHERE CURRENT_TIMESTAMP() - `lastCall` < 1000 * 3600 * 24",
      "SELECT COUNT(*) as allUsers FROM `user`",
      "SELECT COUNT(*) as activeGroups FROM `channel` WHERE `assignee`",
      "SELECT COUNT(*) as allGroups FROM `channel`",
      "SELECT SUM(DATA_LENGTH) as storageSize from information_schema.TABLES"
    ]);
    return { activeUsers, allUsers, activeGroups, allGroups, storageSize };
  },
  createSynchronizer() {
    return new MysqlSynchronizer(this);
  }
});

// packages/plugin-webui/src/index.ts
import_koishi_core7.Context.delegate("webui");
import_koishi_core7.Tables.extend("user", {
  fields: {
    lastCall: "timestamp",
    password: "string(63)",
    token: "string(63)",
    expire: "unsigned(20)"
  }
});
import_koishi_core7.Tables.extend("channel", {
  fields: {
    name: "string(50)",
    activity: "json"
  }
});
import_koishi_utils.template.set("status", {
  bot: "{{ username }}：{{ code ? `无法连接` : `工作中（${currentRate[0]}/min）` }}",
  output: [
    "{{ bots }}",
    "==========",
    "CPU 使用率：{{ (cpu[0] * 100).toFixed() }}% / {{ (cpu[1] * 100).toFixed() }}%",
    "内存使用率：{{ (memory[0] * 100).toFixed() }}% / {{ (memory[1] * 100).toFixed() }}%"
  ].join("\n")
});
var defaultConfig = {
  apiPath: "/status",
  uiPath: "/console",
  selfUrl: "",
  title: "Koishi 控制台",
  expiration: import_koishi_utils.Time.week,
  tickInterval: import_koishi_utils.Time.second * 5,
  statsInternal: import_koishi_utils.Time.minute * 10,
  metaInterval: import_koishi_utils.Time.hour
};
var name = "webui";
function apply(ctx, config = {}) {
  config = Object.assign(defaultConfig, config);
  ctx.webui = new WebServer(ctx, config);
  ctx.router.get(config.apiPath, async (ctx2) => {
    ctx2.set("Access-Control-Allow-Origin", "*");
    ctx2.body = await getStatus();
  });
  ctx.command("status", "查看机器人运行状态").shortcut("你的状态", { prefix: true }).shortcut("你的状况", { prefix: true }).shortcut("运行情况", { prefix: true }).shortcut("运行状态", { prefix: true }).option("all", "-a  查看全部平台").action(async ({ session, options }) => {
    const status = await getStatus();
    if (!options.all) {
      status.bots = status.bots.filter((bot) => bot.platform === session.platform);
    }
    status.bots.toString = () => {
      return status.bots.map((bot) => {
        let output = (0, import_koishi_utils.template)("status.bot", bot);
        if (options.all)
          output = `[${bot.platform}] ` + output;
        return output;
      }).join("\n");
    };
    return (0, import_koishi_utils.template)("status.output", status);
  });
  async function getStatus() {
    const [profile, meta] = await Promise.all([
      ctx.webui.sources.profile.get(),
      ctx.webui.sources.meta.get()
    ]);
    return __spreadValues(__spreadValues({}, profile), meta);
  }
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  Awesome,
  Meta,
  Profile,
  Registry,
  SocketHandle,
  Statistics,
  WebServer,
  apply,
  name
});
//# sourceMappingURL=index.js.map

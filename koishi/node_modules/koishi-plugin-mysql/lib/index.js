var __create = Object.create;
var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __markAsModule = (target) => __defProp(target, "__esModule", { value: true });
var __export = (target, all) => {
  __markAsModule(target);
  for (var name2 in all)
    __defProp(target, name2, { get: all[name2], enumerable: true });
};
var __reExport = (target, module2, desc) => {
  if (module2 && typeof module2 === "object" || typeof module2 === "function") {
    for (let key of __getOwnPropNames(module2))
      if (!__hasOwnProp.call(target, key) && key !== "default")
        __defProp(target, key, { get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable });
  }
  return target;
};
var __toModule = (module2) => {
  return __reExport(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, "default", module2 && module2.__esModule && "default" in module2 ? { get: () => module2.default, enumerable: true } : { value: module2, enumerable: true })), module2);
};

// packages/plugin-mysql/src/index.ts
__export(exports, {
  apply: () => apply,
  default: () => src_default,
  name: () => name
});

// packages/plugin-mysql/src/database.ts
var import_mysql = __toModule(require("mysql"));
var Koishi = __toModule(require("koishi-core"));
var import_koishi_utils = __toModule(require("koishi-utils"));
var import_util = __toModule(require("util"));
var logger = new import_koishi_utils.Logger("mysql");
function stringify(value, table, field) {
  var _a, _b;
  const type = (_a = MysqlDatabase.tables[table]) == null ? void 0 : _a[field];
  if (typeof type === "object")
    return type.stringify(value);
  const meta = (_b = Koishi.Tables.config[table]) == null ? void 0 : _b.fields[field];
  if ((meta == null ? void 0 : meta.type) === "json") {
    return JSON.stringify(value);
  } else if ((meta == null ? void 0 : meta.type) === "list") {
    return value.join(",");
  }
  return value;
}
function escape(value, table, field) {
  return (0, import_mysql.escape)(stringify(value, table, field));
}
function getIntegerType(length = 11) {
  if (length <= 4)
    return "tinyint";
  if (length <= 6)
    return "smallint";
  if (length <= 9)
    return "mediumint";
  if (length <= 11)
    return "int";
  return "bigint";
}
function getTypeDefinition({ type, length, precision, scale }) {
  switch (type) {
    case "float":
    case "double":
    case "date":
    case "time":
    case "timestamp":
      return type;
    case "integer":
      return getIntegerType(length);
    case "unsigned":
      return `${getIntegerType(length)} unsigned`;
    case "decimal":
      return `decimal(${precision}, ${scale}) unsigned`;
    case "char":
      return `char(${length || 255})`;
    case "string":
      return `char(${length || 255})`;
    case "text":
      return `text(${length || 65535})`;
    case "list":
      return `text(${length || 65535})`;
    case "json":
      return `text(${length || 65535})`;
  }
}
function createIndex(keys) {
  return (0, import_koishi_utils.makeArray)(keys).map((key) => (0, import_mysql.escapeId)(key)).join(", ");
}
var MysqlDatabase = class {
  constructor(app, config) {
    this.app = app;
    this.mysql = this;
    this.columns = {};
    this.joinKeys = (keys) => {
      return keys ? keys.map((key) => key.includes("`") ? key : `\`${key}\``).join(",") : "*";
    };
    this.$in = (table, key, values) => {
      return `${this.escapeId(key)} IN (${values.map((val) => this.escape(val, table, key)).join(", ")})`;
    };
    this.formatValues = (table, data, keys) => {
      return keys.map((key) => {
        if (typeof data[key] !== "object" || import_util.types.isDate(data[key]))
          return data[key];
        return stringify(data[key], table, key);
      });
    };
    this.config = __spreadValues({
      database: "koishi",
      charset: "utf8mb4_general_ci",
      multipleStatements: true,
      typeCast: (field, next) => {
        var _a, _b, _c;
        const { orgName, orgTable } = field.packet;
        const type = (_a = MysqlDatabase.tables[orgTable]) == null ? void 0 : _a[orgName];
        if (typeof type === "object")
          return type.parse(field);
        const meta = (_b = Koishi.Tables.config[orgTable]) == null ? void 0 : _b.fields[orgName];
        if ((meta == null ? void 0 : meta.type) === "string") {
          return field.string();
        } else if ((meta == null ? void 0 : meta.type) === "json") {
          return JSON.parse(field.string()) || meta.initial;
        } else if ((meta == null ? void 0 : meta.type) === "list") {
          const source = field.string();
          return source ? source.split(",") : [];
        }
        if (field.type === "BIT") {
          return Boolean((_c = field.buffer()) == null ? void 0 : _c.readUInt8(0));
        } else {
          return next();
        }
      }
    }, config);
  }
  inferFields(table, keys) {
    if (!keys)
      return;
    const types2 = MysqlDatabase.tables[table] || {};
    return keys.map((key) => {
      const type = types2[key];
      return typeof type === "function" ? `${type()} AS ${key}` : key;
    });
  }
  getColDefs(name2, cols = []) {
    const table = Koishi.Tables.config[name2];
    const { primary, foreign, type } = table;
    const fields = __spreadValues({}, table.fields);
    const unique = [...table.unique];
    const keys = this.columns[name2] || [];
    if (name2 === "user") {
      const platforms = new Set(this.app.bots.map((bot) => bot.platform));
      for (const name3 of platforms) {
        fields[name3] = { type: "string", length: 63 };
        unique.push(name3);
      }
    }
    for (const key in MysqlDatabase.tables[name2]) {
      const value = MysqlDatabase.tables[name2][key];
      if (keys.includes(key) || typeof value === "function")
        continue;
      cols.push(`${(0, import_mysql.escapeId)(key)} ${MysqlDatabase.Domain.definition(value)}`);
    }
    for (const key in fields) {
      if (keys.includes(key))
        continue;
      const { initial, nullable = initial === void 0 || initial === null } = fields[key];
      let def = (0, import_mysql.escapeId)(key);
      if (key === primary && type === "incremental") {
        def += " bigint(20) unsigned not null auto_increment";
      } else {
        const typedef = getTypeDefinition(fields[key]);
        def += " " + typedef + (nullable ? " " : " not ") + "null";
        if (initial && !typedef.startsWith("text")) {
          def += " default " + escape(initial, name2, key);
        }
      }
      cols.push(def);
    }
    if (!keys.length) {
      cols.push(`primary key (${createIndex(primary)})`);
      for (const key of unique) {
        cols.push(`unique index (${createIndex(key)})`);
      }
      for (const key in foreign) {
        const [table2, key2] = foreign[key];
        cols.push(`foreign key (${(0, import_mysql.escapeId)(key)}) references ${(0, import_mysql.escapeId)(table2)} (${(0, import_mysql.escapeId)(key2)})`);
      }
    }
    return cols;
  }
  async start() {
    var _a;
    this.pool = (0, import_mysql.createPool)(this.config);
    const data = await this.query("SELECT TABLE_NAME, COLUMN_NAME from information_schema.columns WHERE TABLE_SCHEMA = ?", [this.config.database]);
    for (const { TABLE_NAME, COLUMN_NAME } of data) {
      ((_a = this.columns)[TABLE_NAME] || (_a[TABLE_NAME] = [])).push(COLUMN_NAME);
    }
    for (const name2 in Koishi.Tables.config) {
      const cols = this.getColDefs(name2);
      if (!this.columns[name2]) {
        logger.info("auto creating table %c", name2);
        await this.query(`CREATE TABLE ?? (${cols.join(",")}) COLLATE = ?`, [name2, this.config.charset]);
      } else if (cols.length) {
        logger.info("auto updating table %c", name2);
        await this.query(`ALTER TABLE ?? ${cols.map((def) => "ADD " + def).join(",")}`, [name2]);
      }
    }
  }
  async query(source, values) {
    if (Array.isArray(source)) {
      if (this.config.multipleStatements) {
        return this.query(source.join(";"), values);
      } else {
        const result = [];
        for (const sql of source) {
          result.push(await this.query(sql, values));
        }
        return result;
      }
    }
    const error = new Error();
    return new Promise((resolve, reject) => {
      const sql = (0, import_mysql.format)(source, values);
      logger.debug("[sql]", sql);
      this.pool.query(sql, (err, results) => {
        if (!err)
          return resolve(results);
        logger.warn(sql);
        err.stack = err.message + error.stack.slice(7);
        if (err.code === "ER_DUP_ENTRY") {
          err[Symbol.for("koishi.error-type")] = "duplicate-entry";
        }
        reject(err);
      });
    });
  }
  select(table, fields, conditional, values = []) {
    logger.debug(`[select] ${table}: ${fields ? fields.join(", ") : "*"}`);
    const sql = "SELECT " + this.joinKeys(fields) + (table.includes(".") ? `FROM ${table}` : " FROM `" + table + `\` _${table}`) + (conditional ? " WHERE " + conditional : "");
    return this.query(sql, values);
  }
  async count(table, conditional) {
    const [{ "COUNT(*)": count }] = await this.query(`SELECT COUNT(*) FROM ?? ${conditional ? "WHERE " + conditional : ""}`, [table]);
    return count;
  }
  stop() {
    this.pool.end();
  }
};
MysqlDatabase.prototype.escape = escape;
MysqlDatabase.prototype.escapeId = import_mysql.escapeId;
(function(MysqlDatabase2) {
  MysqlDatabase2.tables = {
    user: {},
    channel: {}
  };
  let Domain;
  (function(Domain2) {
    function definition(domain) {
      return typeof domain === "string" ? domain : domain.definition;
    }
    Domain2.definition = definition;
    class String {
      constructor(definition2 = "TEXT") {
        this.definition = definition2;
      }
      parse(field) {
        return field.string();
      }
      stringify(value) {
        return value;
      }
    }
    Domain2.String = String;
    class Array2 {
      constructor(definition2 = "TEXT") {
        this.definition = definition2;
      }
      parse(field) {
        const source = field.string();
        return source ? source.split(",") : [];
      }
      stringify(value) {
        return value.join(",");
      }
    }
    Domain2.Array = Array2;
    class Json {
      constructor(definition2 = "text", defaultValue) {
        this.definition = definition2;
        this.defaultValue = defaultValue;
      }
      parse(field) {
        return JSON.parse(field.string()) || this.defaultValue;
      }
      stringify(value) {
        return JSON.stringify(value);
      }
    }
    Domain2.Json = Json;
  })(Domain = MysqlDatabase2.Domain || (MysqlDatabase2.Domain = {}));
})(MysqlDatabase || (MysqlDatabase = {}));
var database_default = MysqlDatabase;

// packages/plugin-mysql/src/index.ts
var import_koishi_core = __toModule(require("koishi-core"));
var import_koishi_utils2 = __toModule(require("koishi-utils"));
var import_mysql2 = __toModule(require("mysql"));
var Koishi2 = __toModule(require("koishi-core"));
var src_default = database_default;
function createMemberQuery(key, value, notStr = "") {
  if (!value.length)
    return notStr ? "1" : "0";
  return `${key}${notStr} IN (${value.map((val) => (0, import_mysql2.escape)(val)).join(", ")})`;
}
function createRegExpQuery(key, value) {
  return `${key} REGEXP ${(0, import_mysql2.escape)(value.source)}`;
}
function createElementQuery(key, value) {
  return `FIND_IN_SET(${(0, import_mysql2.escape)(value)}, ${key})`;
}
function comparator(operator) {
  return function(key, value) {
    return `${key} ${operator} ${(0, import_mysql2.escape)(value)}`;
  };
}
var createEqualQuery = comparator("=");
var queryOperators = {
  $eq: createEqualQuery,
  $ne: comparator("!="),
  $gt: comparator(">"),
  $gte: comparator(">="),
  $lt: comparator("<"),
  $lte: comparator("<="),
  $in: (key, value) => createMemberQuery(key, value, ""),
  $nin: (key, value) => createMemberQuery(key, value, " NOT"),
  $regex: createRegExpQuery,
  $regexFor: (key, value) => `${(0, import_mysql2.escape)(value)} REGEXP ${key}`,
  $bitsAllSet: (key, value) => `${key} & ${(0, import_mysql2.escape)(value)} = ${(0, import_mysql2.escape)(value)}`,
  $bitsAllClear: (key, value) => `${key} & ${(0, import_mysql2.escape)(value)} = 0`,
  $bitsAnySet: (key, value) => `${key} & ${(0, import_mysql2.escape)(value)} != 0`,
  $bitsAnyClear: (key, value) => `${key} & ${(0, import_mysql2.escape)(value)} != ${(0, import_mysql2.escape)(value)}`,
  $el: (key, value) => {
    if (Array.isArray(value)) {
      return `(${value.map((value2) => createElementQuery(key, value2)).join(" || ")})`;
    } else if (typeof value !== "number" && typeof value !== "string") {
      throw new TypeError("query expr under $el is not supported");
    } else {
      return createElementQuery(key, value);
    }
  },
  $size: (key, value) => {
    if (!value)
      return `!${key}`;
    return `${key} && LENGTH(${key}) - LENGTH(REPLACE(${key}, ",", "")) = ${(0, import_mysql2.escape)(value)} - 1`;
  }
};
function binary(operator) {
  return function([left, right]) {
    return `(${parseEval(left)} ${operator} ${parseEval(right)})`;
  };
}
var evalOperators = {
  $add: (args) => `(${args.map(parseEval).join(" + ")})`,
  $multiply: (args) => `(${args.map(parseEval).join(" * ")})`,
  $subtract: binary("-"),
  $divide: binary("/"),
  $eq: binary("="),
  $ne: binary("!="),
  $gt: binary(">"),
  $gte: binary(">="),
  $lt: binary("<"),
  $lte: binary("<="),
  $sum: (expr) => `ifnull(sum(${parseEval(expr)}), 0)`,
  $avg: (expr) => `avg(${parseEval(expr)})`,
  $min: (expr) => `$min(${parseEval(expr)})`,
  $max: (expr) => `max(${parseEval(expr)})`,
  $count: (expr) => `count(distinct ${parseEval(expr)})`
};
function parseQuery(query) {
  const conditions = [];
  for (const key in query) {
    if (key === "$not") {
      conditions.push(`!(${parseQuery(query.$not)})`);
      continue;
    } else if (key === "$and") {
      conditions.push(...query.$and.map(parseQuery));
      continue;
    } else if (key === "$or") {
      if (!query.$or.length)
        return "0";
      conditions.push(`(${query.$or.map(parseQuery).join(" || ")})`);
      continue;
    } else if (key === "$expr") {
      conditions.push(parseEval(query.$expr));
      continue;
    }
    const value = query[key];
    const escKey = (0, import_mysql2.escapeId)(key);
    if (Array.isArray(value)) {
      conditions.push(createMemberQuery(escKey, value));
      continue;
    } else if (value instanceof RegExp) {
      conditions.push(createRegExpQuery(escKey, value));
      continue;
    } else if (typeof value === "string" || typeof value === "number" || value instanceof Date) {
      conditions.push(createEqualQuery(escKey, value));
      continue;
    }
    for (const prop in value) {
      if (prop in queryOperators) {
        conditions.push(queryOperators[prop](escKey, value[prop]));
      }
    }
  }
  if (!conditions.length)
    return "1";
  if (conditions.includes("0"))
    return "0";
  return conditions.join(" && ");
}
function parseEval(expr) {
  if (typeof expr === "string") {
    return (0, import_mysql2.escapeId)(expr);
  } else if (typeof expr === "number" || typeof expr === "boolean") {
    return (0, import_mysql2.escape)(expr);
  }
  for (const key in expr) {
    if (key in evalOperators) {
      return evalOperators[key](expr[key]);
    }
  }
}
import_koishi_core.Database.extend(database_default, {
  async drop(name2) {
    if (name2) {
      await this.query(`DROP TABLE ${(0, import_mysql2.escapeId)(name2)}`);
    } else {
      const data = await this.select("information_schema.tables", ["TABLE_NAME"], "TABLE_SCHEMA = ?", [this.config.database]);
      if (!data.length)
        return;
      await this.query(data.map(({ TABLE_NAME }) => `DROP TABLE ${(0, import_mysql2.escapeId)(TABLE_NAME)}`).join("; "));
    }
  },
  async get(name2, query, modifier) {
    const filter = parseQuery(import_koishi_core.Query.resolve(name2, query));
    if (filter === "0")
      return [];
    const { fields, limit, offset } = import_koishi_core.Query.resolveModifier(modifier);
    const keys = this.joinKeys(this.inferFields(name2, fields));
    let sql = `SELECT ${keys} FROM ${name2} _${name2} WHERE ${filter}`;
    if (limit)
      sql += " LIMIT " + limit;
    if (offset)
      sql += " OFFSET " + offset;
    return this.query(sql);
  },
  async remove(name2, query) {
    const filter = parseQuery(import_koishi_core.Query.resolve(name2, query));
    if (filter === "0")
      return;
    await this.query("DELETE FROM ?? WHERE " + filter, [name2]);
  },
  async create(name2, data) {
    data = __spreadValues(__spreadValues({}, Koishi2.Tables.create(name2)), data);
    const keys = Object.keys(data);
    const header = await this.query(`INSERT INTO ?? (${this.joinKeys(keys)}) VALUES (${keys.map(() => "?").join(", ")})`, [name2, ...this.formatValues(name2, data, keys)]);
    return __spreadProps(__spreadValues({}, data), { id: header.insertId });
  },
  async update(name2, data, key) {
    if (!data.length)
      return;
    const { fields, primary } = Koishi2.Tables.config[name2];
    const updateFields = Object.keys(data[0]);
    const fallback = Koishi2.Tables.create(name2);
    const keys = Object.keys(fields);
    key || (key = primary);
    data = data.map((item) => __spreadValues(__spreadValues({}, fallback), item));
    const placeholder = `(${keys.map(() => "?").join(", ")})`;
    const update = (0, import_koishi_utils2.difference)(updateFields, [key]).map((key2) => {
      key2 = (0, import_mysql2.escapeId)(key2);
      return `${key2} = VALUES(${key2})`;
    }).join(", ");
    await this.query(`INSERT INTO ${(0, import_mysql2.escapeId)(name2)} (${this.joinKeys(keys)}) VALUES ${data.map(() => placeholder).join(", ")}
      ON DUPLICATE KEY UPDATE ${update}`, [].concat(...data.map((data2) => this.formatValues(name2, data2, keys))));
  },
  async aggregate(name2, fields, query) {
    const keys = Object.keys(fields);
    if (!keys.length)
      return {};
    const filter = parseQuery(import_koishi_core.Query.resolve(name2, query));
    const exprs = keys.map((key) => `${parseEval(fields[key])} AS ${(0, import_mysql2.escapeId)(key)}`).join(", ");
    const [data] = await this.query(`SELECT ${exprs} FROM ${name2} WHERE ${filter}`);
    return data;
  },
  async getUser(type, id, modifier) {
    const { fields } = import_koishi_core.Query.resolveModifier(modifier);
    if (fields && !fields.length) {
      return Array.isArray(id) ? id.map((id2) => ({ [type]: id2 })) : { [type]: id };
    }
    const data = await this.get("user", { [type]: id }, modifier);
    if (Array.isArray(id))
      return data;
    return data[0] && __spreadProps(__spreadValues({}, data[0]), { [type]: id });
  },
  async createUser(type, id, data) {
    data[type] = id;
    const newKeys = Object.keys(data);
    const assignments = (0, import_koishi_utils2.difference)(newKeys, [type]).map((key) => {
      key = this.escapeId(key);
      return `${key} = VALUES(${key})`;
    }).join(", ");
    const user = Object.assign(import_koishi_core.User.create(type, id), data);
    const keys = Object.keys(user);
    await this.query(`INSERT INTO ?? (${this.joinKeys(keys)}) VALUES (${keys.map(() => "?").join(", ")})
      ON DUPLICATE KEY UPDATE ${assignments}`, ["user", ...this.formatValues("user", user, keys)]);
  },
  async setUser(type, id, data) {
    data[type] = id;
    const keys = Object.keys(data);
    const assignments = (0, import_koishi_utils2.difference)(keys, [type]).map((key) => {
      return `${this.escapeId(key)} = ${this.escape(data[key], "user", key)}`;
    }).join(", ");
    await this.query(`UPDATE ?? SET ${assignments} WHERE ?? = ?`, ["user", type, id]);
  },
  async getChannel(type, pid, modifier) {
    const { fields } = import_koishi_core.Query.resolveModifier(modifier);
    if (fields && !fields.length) {
      return Array.isArray(pid) ? pid.map((id2) => ({ id: `${type}:${id2}` })) : { id: `${type}:${pid}` };
    }
    const id = Array.isArray(pid) ? pid.map((id2) => `${type}:${id2}`) : `${type}:${pid}`;
    const data = await this.get("channel", { id }, modifier);
    if (Array.isArray(pid))
      return data;
    return data[0] && __spreadProps(__spreadValues({}, data[0]), { id: `${type}:${pid}` });
  },
  async getAssignedChannels(fields, assignMap = this.app.getSelfIds()) {
    return this.select("channel", fields, Object.entries(assignMap).map(([type, ids]) => {
      return [
        `LEFT(\`id\`, ${type.length}) = ${this.escape(type)}`,
        `\`assignee\` IN (${ids.map((id) => this.escape(id)).join(",")})`
      ].join(" AND ");
    }).join(" OR "));
  },
  async createChannel(type, pid, data) {
    data.id = `${type}:${pid}`;
    const newKeys = Object.keys(data);
    if (!newKeys.length)
      return;
    const assignments = (0, import_koishi_utils2.difference)(newKeys, ["id"]).map((key) => {
      key = this.escapeId(key);
      return `${key} = VALUES(${key})`;
    });
    const channel = Object.assign(import_koishi_core.Channel.create(type, pid), data);
    const keys = Object.keys(channel);
    await this.query(`INSERT INTO ?? (${this.joinKeys(keys)}) VALUES (${keys.map(() => "?").join(", ")})
      ON DUPLICATE KEY UPDATE ${assignments.join(", ")}`, ["channel", ...this.formatValues("channel", channel, keys)]);
  },
  async setChannel(type, pid, data) {
    data.id = `${type}:${pid}`;
    const keys = Object.keys(data);
    if (!keys.length)
      return;
    const assignments = (0, import_koishi_utils2.difference)(keys, ["id"]).map((key) => {
      return `${this.escapeId(key)} = ${this.escape(data[key], "channel", key)}`;
    }).join(", ");
    await this.query(`UPDATE ?? SET ${assignments} WHERE ?? = ?`, ["channel", "id", data.id]);
  }
});
var name = "mysql";
function apply(ctx, config = {}) {
  const db = new database_default(ctx.app, config);
  ctx.database = db;
  ctx.before("connect", () => db.start());
  ctx.before("disconnect", () => db.stop());
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  apply,
  name
});
//# sourceMappingURL=index.js.map

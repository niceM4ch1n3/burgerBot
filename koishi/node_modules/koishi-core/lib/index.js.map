{
  "version": 3,
  "sources": ["../src/index.ts", "../src/adapter.ts", "../src/session.ts", "../src/database.ts", "../src/command.ts", "../src/parser.ts", "../src/app.ts", "../src/context.ts", "../src/help.ts"],
  "sourcesContent": ["export * from 'koishi-utils'\nexport * from './adapter'\nexport * from './app'\nexport * from './command'\nexport * from './context'\nexport * from './database'\nexport * from './help'\nexport * from './parser'\nexport * from './session'\n\ndeclare const KOISHI_VERSION: string\nexport const version = KOISHI_VERSION\n\ndeclare module 'koa' {\n  // koa-bodyparser\n  interface Request {\n    body?: any\n    rawBody: string\n  }\n}\n", "import { Logger, paramCase, sleep, Time } from 'koishi-utils'\nimport { Session } from './session'\nimport { App } from './app'\nimport WebSocket from 'ws'\n\nexport interface BotOptions {\n  type?: string\n  token?: string\n  selfId?: string\n}\n\ntype BotList<T extends Bot> = Array<T> & Record<string, T>\n\nexport function createBots<T extends Bot>(key: 'selfId' | 'sid') {\n  const bots = [] as BotList<T>\n  return new Proxy(bots, {\n    get(target, prop) {\n      return typeof prop === 'symbol'\n        ? Reflect.get(target, prop)\n        : target[prop] || target.find(bot => bot[key] === prop)\n    },\n  })\n}\n\nexport abstract class Adapter<P extends Platform = Platform> {\n  public bots: BotList<Bot.Instance<P>> = createBots('selfId')\n\n  abstract start(): Promise<void>\n  abstract stop?(): void\n\n  constructor(public app: App, private Bot?: Bot.Constructor<P>) {}\n\n  create(options: BotOptions, constructor = this.Bot) {\n    const bot = new constructor(this, options)\n    this.bots.push(bot)\n    this.app.bots.push(bot)\n    return bot\n  }\n\n  dispatch(session: Session) {\n    if (this.app.status !== App.Status.open) return\n    const events: string[] = [session.type]\n    if (session.subtype) {\n      events.unshift(events[0] + '/' + session.subtype)\n      if (session.subsubtype) {\n        events.unshift(events[0] + '/' + session.subsubtype)\n      }\n    }\n    for (const event of events) {\n      this.app.emit(session, paramCase<any>(event), session)\n    }\n  }\n}\n\nconst logger = new Logger('adapter')\n\nexport namespace Adapter {\n  export type Constructor<T extends Platform = Platform> = new (app: App, bot: BotOptions) => Adapter<T>\n\n  export type Instances = {\n    [K in string]: K extends `${infer T}:${any}` ? Adapter<T & Platform> : Adapter<K & Platform>\n  }\n\n  export const types: Record<string, Constructor> = {}\n\n  export function from(app: App, bot: BotOptions) {\n    const type = bot.type = bot.type.toLowerCase()\n    if (app.adapters[type]) return app.adapters[type]\n    const constructor = Adapter.types[type]\n    if (!constructor) {\n      const platform = type.split(':', 1)[0]\n      throw new Error(`unsupported platform \"${platform}\", you should import the adapter yourself`)\n    }\n    const adapter = new constructor(app, bot)\n    return app.adapters[bot.type] = adapter\n  }\n\n  export function redirect(target: string | ((bot: BotOptions) => string)) {\n    const callback = typeof target === 'string' ? () => target : target\n    return class {\n      constructor(app: App, bot: BotOptions) {\n        logger.debug('infer type as %c', bot.type = callback(bot))\n        return from(app, bot)\n      }\n    } as Constructor\n  }\n\n  export interface WsClientOptions {\n    retryLazy?: number\n    retryTimes?: number\n    retryInterval?: number\n  }\n\n  export abstract class WsClient<P extends Platform = Platform> extends Adapter<P> {\n    abstract prepare(bot: Bot.Instance<P>): WebSocket | Promise<WebSocket>\n    abstract connect(bot: Bot.Instance<P>): Promise<void>\n\n    private _listening = false\n    public options: WsClientOptions\n\n    static options: WsClientOptions = {\n      retryLazy: Time.minute,\n      retryInterval: 5 * Time.second,\n      retryTimes: 6,\n    }\n\n    constructor(app: App, Bot: Bot.Constructor<P>, options: WsClientOptions = {}) {\n      super(app, Bot)\n      this.options = { ...WsClient.options, ...options }\n    }\n\n    private async _listen(bot: Bot.Instance<P>) {\n      let _retryCount = 0\n      const { retryTimes, retryInterval, retryLazy } = this.options\n\n      const connect = async (resolve: (value: void) => void, reject: (reason: Error) => void) => {\n        logger.debug('websocket client opening')\n        bot.status = Bot.Status.CONNECTING\n        const socket = await this.prepare(bot)\n        const url = socket.url.replace(/\\?.+/, '')\n\n        socket.on('error', error => logger.debug(error))\n\n        socket.on('close', (code, reason) => {\n          bot.socket = null\n          bot.status = Bot.Status.NET_ERROR\n          logger.debug(`websocket closed with ${code}`)\n          if (!this._listening) return\n\n          // remove query args to protect privacy\n          const message = reason || `failed to connect to ${url}`\n          let timeout = retryInterval\n          if (_retryCount >= retryTimes) {\n            if (this.app.status === App.Status.open) {\n              timeout = retryLazy\n            } else {\n              return reject(new Error(message))\n            }\n          }\n\n          _retryCount++\n          logger.warn(`${message}, will retry in ${Time.formatTimeShort(timeout)}...`)\n          setTimeout(() => {\n            if (this._listening) connect(resolve, reject)\n          }, timeout)\n        })\n\n        socket.on('open', () => {\n          _retryCount = 0\n          bot.socket = socket\n          logger.info('connect to ws server:', url)\n          this.connect(bot).then(() => {\n            bot.status = Bot.Status.GOOD\n            resolve()\n          }, reject)\n        })\n      }\n\n      return new Promise(connect)\n    }\n\n    async start() {\n      this._listening = true\n      await Promise.all(this.bots.map(bot => this._listen(bot)))\n    }\n\n    stop() {\n      this._listening = false\n      logger.debug('websocket client closing')\n      for (const bot of this.bots) {\n        bot.socket?.close()\n      }\n    }\n  }\n}\n\nexport interface Bot<P = Platform> extends BotOptions, UserBase {\n  [Session.send](session: Session, message: string): Promise<void>\n\n  status: Bot.Status\n  socket?: WebSocket\n  version?: string\n  getStatus(): Promise<Bot.Status>\n\n  // message\n  sendMessage(channelId: string, content: string, groupId?: string): Promise<string>\n  sendPrivateMessage(userId: string, content: string): Promise<string>\n  getMessage(channelId: string, messageId: string): Promise<MessageInfo>\n  editMessage(channelId: string, messageId: string, content: string): Promise<void>\n  deleteMessage(channelId: string, messageId: string): Promise<void>\n\n  // user\n  getSelf(): Promise<UserInfo>\n  getUser(userId: string): Promise<UserInfo>\n  getFriendList(): Promise<UserInfo[]>\n  deleteFriend(userId: string): Promise<void>\n\n  // group\n  getGroup(groupId: string): Promise<GroupInfo>\n  getGroupList(): Promise<GroupInfo[]>\n\n  // group member\n  getGroupMember(groupId: string, userId: string): Promise<GroupMemberInfo>\n  getGroupMemberList(groupId: string): Promise<GroupMemberInfo[]>\n\n  // channel\n  getChannel(channelId: string): Promise<ChannelInfo>\n  getChannelList(groupId: string): Promise<ChannelInfo[]>\n\n  // request\n  handleFriendRequest(messageId: string, approve: boolean, comment?: string): Promise<void>\n  handleGroupRequest(messageId: string, approve: boolean, comment?: string): Promise<void>\n  handleGroupMemberRequest(messageId: string, approve: boolean, comment?: string): Promise<void>\n}\n\nexport class Bot<P extends Platform> {\n  readonly app: App\n  readonly logger: Logger\n  readonly platform: P\n\n  constructor(public adapter: Adapter<P>, options: BotOptions) {\n    Object.assign(this, options)\n    this.app = adapter.app\n    this.platform = this.type.split(':', 1)[0] as never\n    this.logger = new Logger(this.platform)\n    this.status = Bot.Status.BOT_IDLE\n  }\n\n  get sid() {\n    return `${this.platform}:${this.selfId}`\n  }\n\n  async getStatus() {\n    return this.status\n  }\n\n  createSession(session: Partial<Session<never, never, P, 'send'>>) {\n    return new Session<never, never, P, 'send'>(this.app, {\n      ...session,\n      type: 'send',\n      selfId: this.selfId,\n      platform: this.platform,\n      timestamp: Date.now(),\n      author: {\n        userId: this.selfId,\n        username: this.username,\n        avatar: this.avatar,\n        discriminator: this.discriminator,\n        isBot: true,\n      },\n    })\n  }\n\n  async getGroupMemberMap(groupId: string) {\n    const list = await this.getGroupMemberList(groupId)\n    return Object.fromEntries(list.map(info => [info.userId, info.nickname || info.username]))\n  }\n\n  async broadcast(channels: string[], content: string, delay = this.app.options.delay.broadcast) {\n    const messageIds: string[] = []\n    for (let index = 0; index < channels.length; index++) {\n      if (index && delay) await sleep(delay)\n      try {\n        messageIds.push(await this.sendMessage(channels[index], content, 'unknown'))\n      } catch (error) {\n        this.app.logger('bot').warn(error)\n      }\n    }\n    return messageIds\n  }\n}\n\nexport namespace Bot {\n  export interface Platforms {}\n\n  export type Instance<T extends Platform> = [T] extends [never] ? Bot<T> : Platforms[T]\n  export type Constructor<T extends Platform> = new (adapter: Adapter, options: BotOptions) => Instance<T>\n\n  export enum Status {\n    /** 正常运行 */\n    GOOD,\n    /** 机器人处于闲置状态 */\n    BOT_IDLE,\n    /** 机器人离线 */\n    BOT_OFFLINE,\n    /** 无法获得状态 */\n    NET_ERROR,\n    /** 服务器状态异常 */\n    SERVER_ERROR,\n    /** 机器人被封禁 */\n    BANNED,\n    /** 正在尝试连接 */\n    CONNECTING,\n  }\n}\n\nexport type Platform = keyof Bot.Platforms\n\nexport interface ChannelInfo {\n  channelId: string\n  channelName?: string\n}\n\nexport interface GroupInfo {\n  groupId: string\n  groupName?: string\n}\n\nexport interface UserBase {\n  username?: string\n  nickname?: string\n  avatar?: string\n  discriminator?: string\n  isBot?: boolean\n}\n\nexport interface UserInfo extends UserBase {\n  userId: string\n}\n\nexport interface GroupMemberInfo extends UserInfo {\n  roles?: string[]\n}\n\nexport interface AuthorInfo extends GroupMemberInfo {\n  anonymous?: string\n}\n\nexport interface RoleInfo {\n  id: string\n}\n\nexport interface MessageBase {\n  messageId?: string\n  channelId?: string\n  groupId?: string\n  userId?: string\n  content?: string\n  timestamp?: number\n  author?: AuthorInfo\n  quote?: MessageInfo\n}\n\nexport interface MessageInfo extends MessageBase {\n  subtype?: keyof Session.Events['message']\n}\n", "import LruCache from 'lru-cache'\nimport { distance } from 'fastest-levenshtein'\nimport { User, Channel, TableType, Tables } from './database'\nimport { Command } from './command'\nimport { contain, observe, Logger, defineProperty, Random, template, remove, noop, segment } from 'koishi-utils'\nimport { Argv } from './parser'\nimport { Middleware, NextFunction } from './context'\nimport { App } from './app'\nimport { Bot, ChannelInfo, GroupInfo, MessageBase, Platform } from './adapter'\n\nconst logger = new Logger('session')\n\ntype UnionToIntersection<U> = (U extends any ? (key: U) => void : never) extends (key: infer I) => void ? I : never\ntype Flatten<T, K extends keyof T = keyof T> = UnionToIntersection<T[K]>\ntype InnerKeys<T, K extends keyof T = keyof T> = keyof Flatten<T> & keyof Flatten<T, K>\n\nexport interface Session<U, G, P, X, Y> extends MessageBase, Partial<ChannelInfo>, Partial<GroupInfo> {}\n\nexport namespace Session {\n  type Genres = 'friend' | 'channel' | 'group' | 'group-member' | 'group-role' | 'group-file' | 'group-emoji'\n  type Actions = 'added' | 'deleted' | 'updated'\n\n  export interface Events extends Record<`${Genres}-${Actions}`, {}> {}\n\n  export type MessageAction = 'message' | 'message-deleted' | 'message-updated' | 'send'\n  export type Message = Session<never, never, Platform, MessageAction>\n  export interface Events extends Record<MessageAction, MessageType> {}\n\n  export type RequestAction = 'friend-request' | 'group-request' | 'group-member-request'\n  export type Request = Session<never, never, Platform, RequestAction>\n  export interface Events extends Record<RequestAction, {}> {}\n\n  export interface Events {\n    'friend-request': {}\n    'group-request': {}\n    'group-member-request': {}\n    'group-added': GroupMemberChangeType\n    'group-member-added': GroupMemberChangeType\n    'group-deleted': GroupMemberChangeType\n    'group-member-deleted': GroupMemberChangeType\n    'group-member': {\n      'role': {}\n      'ban': {}\n      'nickname': {}\n    }\n    'notice': {\n      'poke': {}\n      'lucky-king': {}\n      'honor': {\n        'talkative': {}\n        'performer': {}\n        'emotion': {}\n      }\n    }\n    'reaction-added': {}\n    'reaction-deleted': {\n      'one': {}\n      'all': {}\n      'emoji': {}\n    }\n  }\n\n  export interface GroupMemberChangeType {\n    'active': {}\n    'passive': {}\n  }\n\n  export interface MessageType {\n    'private': {}\n    'group': {}\n  }\n\n  type ParamX<X> = Extract<keyof Events, X>\n  type ParamY<X, Y> = Extract<InnerKeys<Events, ParamX<X>>, Y>\n\n  export type Payload<X, Y = any> = Session<never, never, Platform, ParamX<X>, ParamY<X, Y>>\n}\n\nexport interface Parsed {\n  content: string\n  prefix: string\n  appel: boolean\n}\n\nexport class Session<\n  U extends User.Field = never,\n  G extends Channel.Field = never,\n  P extends Platform = Platform,\n  X extends keyof Session.Events = keyof Session.Events,\n  Y extends InnerKeys<Session.Events, X> = InnerKeys<Session.Events, X>,\n> {\n  type?: X\n  subtype?: Y\n  subsubtype?: InnerKeys<UnionToIntersection<Session.Events[X]>, Y>\n  platform?: P\n\n  selfId?: string\n  operatorId?: string\n  targetId?: string\n  duration?: number\n  file?: FileInfo\n\n  readonly app: App\n  readonly bot: Bot.Instance<P>\n  readonly sid: string\n  uid: string\n  cid: string\n  gid: string\n\n  id?: string\n  argv?: Argv<U, G>\n  user?: User.Observed<U>\n  channel?: Channel.Observed<G>\n  parsed?: Parsed\n\n  private _delay?: number\n  private _queued: Promise<void>\n  private _hooks: (() => void)[]\n  private _promise: Promise<string>\n\n  static readonly send = Symbol.for('koishi.session.send')\n\n  constructor(app: App, session: Partial<Session>) {\n    Object.assign(this, session)\n    defineProperty(this, 'app', app)\n    defineProperty(this, 'user', null)\n    defineProperty(this, 'channel', null)\n    defineProperty(this, 'sid', `${this.platform}:${this.selfId}`)\n    defineProperty(this, 'uid', `${this.platform}:${this.userId}`)\n    defineProperty(this, 'cid', `${this.platform}:${this.channelId}`)\n    defineProperty(this, 'gid', `${this.platform}:${this.groupId}`)\n    defineProperty(this, 'bot', app.bots[this.sid])\n    defineProperty(this, 'id', Random.uuid())\n    defineProperty(this, '_queued', Promise.resolve())\n    defineProperty(this, '_hooks', [])\n  }\n\n  toJSON(): Partial<Session> {\n    return Object.fromEntries(Object.entries(this).filter(([key]) => {\n      return !key.startsWith('_') && !key.startsWith('$')\n    }))\n  }\n\n  private async _preprocess() {\n    let node: segment.Parsed\n    let content = this.app.options.processMessage(this.content)\n    // eslint-disable-next-line no-cond-assign\n    if (node = segment.from(content, { type: 'quote', caret: true })) {\n      content = content.slice(node.capture[0].length).trimStart()\n      this.quote = await this.bot.getMessage(node.data.channelId || this.channelId, node.data.id).catch(noop)\n    }\n    return content\n  }\n\n  async preprocess() {\n    return this._promise ||= this._preprocess()\n  }\n\n  get username(): string {\n    const defaultName = this.user && this.user['name']\n      ? this.user['name']\n      : this.author\n        ? this.author.nickname || this.author.username\n        : this.userId\n    return this.app.chain('appellation', defaultName, this)\n  }\n\n  get database() {\n    return this.app.database\n  }\n\n  async send(message: string) {\n    if (this.bot[Session.send]) {\n      return this.bot[Session.send](this, message)\n    }\n    if (!message) return\n    await this.bot.sendMessage(this.channelId, message, this.groupId)\n  }\n\n  cancelQueued(delay = this.app.options.delay.cancel) {\n    this._hooks.forEach(Reflect.apply)\n    this._delay = delay\n  }\n\n  async sendQueued(content: string, delay?: number) {\n    if (!content) return\n    if (typeof delay === 'undefined') {\n      const { message, character } = this.app.options.delay\n      delay = Math.max(message, character * content.length)\n    }\n    return this._queued = this._queued.then(() => new Promise<void>((resolve) => {\n      const hook = () => {\n        resolve()\n        clearTimeout(timer)\n        remove(this._hooks, hook)\n      }\n      this._hooks.push(hook)\n      const timer = setTimeout(async () => {\n        await this.send(content)\n        this._delay = delay\n        hook()\n      }, this._delay || 0)\n    }))\n  }\n\n  resolveValue<T>(source: T | ((session: Session) => T)): T {\n    return typeof source === 'function' ? Reflect.apply(source, null, [this]) : source\n  }\n\n  async getChannel<K extends Channel.Field = never>(id = this.channelId, assignee = '', fields: K[] = []) {\n    const group = await this.database.getChannel(this.platform, id, fields)\n    if (group) return group\n    const fallback = Channel.create(this.platform, id)\n    fallback.assignee = assignee\n    if (assignee) {\n      await this.database.createChannel(this.platform, id, fallback)\n    }\n    return fallback\n  }\n\n  /** 在当前会话上绑定一个可观测频道实例 */\n  async observeChannel<T extends Channel.Field = never>(fields: Iterable<T> = []): Promise<Channel.Observed<T | G>> {\n    const fieldSet = new Set<Channel.Field>(fields)\n    const { platform, channelId, channel } = this\n\n    // 对于已经绑定可观测频道的，判断字段是否需要自动补充\n    if (channel) {\n      for (const key in channel) {\n        fieldSet.delete(key as any)\n      }\n      if (fieldSet.size) {\n        const data = await this.getChannel(channelId, '', [...fieldSet])\n        this.app._channelCache.set(this.cid, channel._merge(data))\n      }\n      return channel as any\n    }\n\n    // 如果存在满足可用的缓存数据，使用缓存代替数据获取\n    const cache = this.app._channelCache.get(this.cid)\n    const fieldArray = [...fieldSet]\n    const hasActiveCache = cache && contain(Object.keys(cache), fieldArray)\n    if (hasActiveCache) return this.channel = cache as any\n\n    // 绑定一个新的可观测频道实例\n    const assignee = this.resolveValue(this.app.options.autoAssign) ? this.selfId : ''\n    const data = await this.getChannel(channelId, assignee, fieldArray)\n    const newChannel = observe(data, diff => this.database.setChannel(platform, channelId, diff), `channel ${this.cid}`)\n    this.app._channelCache.set(this.cid, newChannel)\n    return this.channel = newChannel\n  }\n\n  async getUser<K extends User.Field = never>(id = this.userId, authority = 0, fields: K[] = []) {\n    const user = await this.database.getUser(this.platform, id, fields)\n    if (user) return user\n    const fallback = User.create(this.platform, id)\n    fallback.authority = authority\n    if (authority) {\n      await this.database.createUser(this.platform, id, fallback)\n    }\n    return fallback\n  }\n\n  /** 在当前会话上绑定一个可观测用户实例 */\n  async observeUser<T extends User.Field = never>(fields: Iterable<T> = []): Promise<User.Observed<T | U>> {\n    const fieldSet = new Set<User.Field>(fields)\n    const { userId, user } = this\n\n    let userCache = this.app._userCache[this.platform]\n    if (!userCache) {\n      userCache = this.app._userCache[this.platform] = new LruCache({\n        max: this.app.options.userCacheLength,\n        maxAge: this.app.options.userCacheAge,\n      })\n    }\n\n    // 对于已经绑定可观测用户的，判断字段是否需要自动补充\n    if (user && !this.author?.anonymous) {\n      for (const key in user) {\n        fieldSet.delete(key as any)\n      }\n      if (fieldSet.size) {\n        const data = await this.getUser(userId, 0, [...fieldSet])\n        userCache.set(userId, user._merge(data))\n      }\n    }\n\n    if (user) return user as any\n\n    // 确保匿名消息不会写回数据库\n    if (this.author?.anonymous) {\n      const fallback = User.create(this.platform, userId)\n      fallback.authority = this.resolveValue(this.app.options.autoAuthorize)\n      const user = observe(fallback, () => Promise.resolve())\n      return this.user = user\n    }\n\n    // 如果存在满足可用的缓存数据，使用缓存代替数据获取\n    const cache = userCache.get(userId)\n    const fieldArray = [...fieldSet]\n    const hasActiveCache = cache && contain(Object.keys(cache), fieldArray)\n    if (hasActiveCache) return this.user = cache as any\n\n    // 绑定一个新的可观测用户实例\n    const data = await this.getUser(userId, this.resolveValue(this.app.options.autoAuthorize), fieldArray)\n    const newUser = observe(data, diff => this.database.setUser(this.platform, userId, diff), `user ${this.uid}`)\n    userCache.set(userId, newUser)\n    return this.user = newUser\n  }\n\n  collect<T extends TableType>(key: T, argv: Argv, fields = new Set<keyof Tables[T]>()) {\n    const collect = (argv: Argv) => {\n      argv.session = this\n      if (argv.tokens) {\n        for (const { inters } of argv.tokens) {\n          inters.forEach(collect)\n        }\n      }\n      if (!this.resolve(argv)) return\n      collectFields(argv, Command[`_${key}Fields`] as any, fields)\n      collectFields(argv, argv.command[`_${key}Fields`] as any, fields)\n    }\n    collect(argv)\n    return fields\n  }\n\n  resolve(argv: Argv) {\n    if (!argv.command) {\n      const { name = this.app.bail('parse', argv, this) } = argv\n      if (!(argv.command = this.app._commands.get(name))) return\n    }\n    if (argv.tokens?.every(token => !token.inters.length)) {\n      const { options, args, error } = argv.command.parse(argv)\n      argv.options = { ...argv.options, ...options }\n      argv.args = [...argv.args || [], ...args]\n      argv.error = error\n    }\n    return argv.command\n  }\n\n  async execute(content: string, next?: true | NextFunction): Promise<string>\n  async execute(argv: Argv, next?: true | NextFunction): Promise<string>\n  async execute(argv: string | Argv, next?: true | NextFunction): Promise<string> {\n    if (typeof argv === 'string') argv = Argv.parse(argv)\n\n    argv.session = this\n    if (argv.tokens) {\n      for (const arg of argv.tokens) {\n        const { inters } = arg\n        const output: string[] = []\n        for (let i = 0; i < inters.length; ++i) {\n          output.push(await this.execute(inters[i], true))\n        }\n        for (let i = inters.length - 1; i >= 0; --i) {\n          const { pos } = inters[i]\n          arg.content = arg.content.slice(0, pos) + output[i] + arg.content.slice(pos)\n        }\n        arg.inters = []\n      }\n      if (!this.resolve(argv)) return ''\n    } else {\n      argv.command ||= this.app._commands.get(argv.name)\n      if (!argv.command) {\n        logger.warn(new Error(`cannot find command ${argv.name}`))\n        return ''\n      }\n    }\n\n    if (!argv.command.context.match(this)) return ''\n\n    if (this.database) {\n      if (this.subtype === 'group') {\n        await this.observeChannel(this.collect('channel', argv))\n      }\n      await this.observeUser(this.collect('user', argv))\n    }\n\n    let shouldEmit = true\n    if (next === true) {\n      shouldEmit = false\n      next = fallback => fallback()\n    }\n\n    const result = await argv.command.execute(argv, next)\n    if (!shouldEmit) return result\n    await this.send(result)\n    return ''\n  }\n\n  middleware(middleware: Middleware) {\n    const identifier = getSessionId(this)\n    return this.app.middleware(async (session, next) => {\n      if (identifier && getSessionId(session) !== identifier) return next()\n      return middleware(session, next)\n    }, true)\n  }\n\n  prompt(timeout = this.app.options.delay.prompt) {\n    return new Promise<string>((resolve) => {\n      const dispose = this.middleware((session) => {\n        clearTimeout(timer)\n        dispose()\n        resolve(session.content)\n      })\n      const timer = setTimeout(() => {\n        dispose()\n        resolve('')\n      }, timeout)\n    })\n  }\n\n  suggest(options: SuggestOptions) {\n    const {\n      target,\n      items,\n      prefix = '',\n      suffix,\n      apply,\n      next = callback => callback(),\n      minSimilarity = this.app.options.minSimilarity,\n    } = options\n\n    let suggestions: string[], minDistance = Infinity\n    for (const name of items) {\n      const dist = distance(name, target)\n      if (name.length <= 2 || dist > name.length * minSimilarity) continue\n      if (dist === minDistance) {\n        suggestions.push(name)\n      } else if (dist < minDistance) {\n        suggestions = [name]\n        minDistance = dist\n      }\n    }\n    if (!suggestions) return next(() => this.send(prefix))\n\n    return next(() => {\n      const message = prefix + template('internal.suggestion', suggestions.map(template.quote).join(template.get('basic.or')))\n      if (suggestions.length > 1) return this.send(message)\n\n      const dispose = this.middleware((session, next) => {\n        dispose()\n        const message = session.content.trim()\n        if (message && message !== '.' && message !== '。') return next()\n        return apply.call(session, suggestions[0], next)\n      })\n\n      return this.send(message + suffix)\n    })\n  }\n}\n\nexport interface SuggestOptions {\n  target: string\n  items: string[]\n  next?: NextFunction\n  prefix?: string\n  suffix: string\n  minSimilarity?: number\n  apply: (this: Session, suggestion: string, next: NextFunction) => void\n}\n\nexport function getSessionId(session: Session) {\n  return '' + session.userId + session.channelId\n}\n\nexport type FieldCollector<T extends TableType, K = keyof Tables[T], A extends any[] = any[], O = {}> =\n  | Iterable<K>\n  | ((argv: Argv<never, never, A, O>, fields: Set<keyof Tables[T]>) => void)\n\nfunction collectFields<T extends TableType>(argv: Argv, collectors: FieldCollector<T>[], fields: Set<keyof Tables[T]>) {\n  for (const collector of collectors) {\n    if (typeof collector === 'function') {\n      collector(argv, fields)\n      continue\n    }\n    for (const field of collector) {\n      fields.add(field)\n    }\n  }\n  return fields\n}\n\nexport interface FileInfo {\n  id: string\n  name: string\n  size: number\n  busid: number\n}\n", "import { MaybeArray, Get, Extract } from 'koishi-utils'\nimport * as utils from 'koishi-utils'\nimport { Platform } from './adapter'\n\nexport type TableType = keyof Tables\n\n// shared types\ntype Primitive = string | number\ntype Comparable = Primitive | Date\n\ntype Keys<O, T = any> = string & {\n  [K in keyof O]: O[K] extends T ? K : never\n}[keyof O]\n\nexport interface Tables {\n  user: User\n  channel: Channel\n}\n\nexport namespace Tables {\n  export interface Field<T = any> {\n    type: Field.Type<T>\n    length?: number\n    nullable?: boolean\n    initial?: T\n    precision?: number\n    scale?: number\n  }\n\n  export namespace Field {\n    export const number: Type[] = ['integer', 'unsigned', 'float', 'double', 'decimal']\n    export const string: Type[] = ['char', 'string', 'text']\n    export const date: Type[] = ['timestamp', 'date', 'time']\n    export const object: Type[] = ['list', 'json']\n\n    export type Type<T = any> =\n      | T extends number ? 'integer' | 'unsigned' | 'float' | 'double' | 'decimal'\n      : T extends string ? 'char' | 'string' | 'text'\n      : T extends Date ? 'timestamp' | 'date' | 'time'\n      : T extends any[] ? 'list' | 'json'\n      : T extends object ? 'json'\n      : never\n\n    type WithParam<S extends string> = S | `${S}(${any})`\n\n    export type Extension<O = any> = {\n      [K in keyof O]?: Field<O[K]> | WithParam<Type<O[K]>>\n    }\n\n    export type Config<O = any> = {\n      [K in keyof O]?: Field<O[K]>\n    }\n\n    const regexp = /^(\\w+)(?:\\((.+)\\))?$/\n\n    export function parse(source: string | Field): Field {\n      if (typeof source !== 'string') return source\n\n      // parse string definition\n      const capture = regexp.exec(source)\n      if (!capture) throw new TypeError('invalid field definition')\n      const type = capture[1] as Type\n      const args = (capture[2] || '').split(',')\n      const field: Field = { type }\n\n      // set default initial value\n      if (field.initial === undefined) {\n        if (number.includes(field.type)) field.initial = 0\n        if (string.includes(field.type)) field.initial = ''\n        if (field.type === 'list') field.initial = []\n        if (field.type === 'json') field.initial = {}\n      }\n\n      // set length information\n      if (type === 'decimal') {\n        field.precision = +args[0]\n        field.scale = +args[1]\n      } else if (args[0]) {\n        field.length = +args[0]\n      }\n\n      return field\n    }\n  }\n\n  export interface Extension<O = any> {\n    type?: 'random' | 'incremental'\n    primary?: Keys<O>\n    unique?: MaybeArray<Keys<O>>[]\n    foreign?: {\n      [K in keyof O]?: [TableType, string]\n    }\n    fields?: Field.Extension<O>\n  }\n\n  export interface Config<O = any> extends Extension<O> {\n    fields?: Field.Config<O>\n  }\n\n  export const config: Record<string, Config> = {}\n\n  export function extend<T extends TableType>(name: T, meta?: Extension<Tables[T]>): void\n  export function extend(name: string, meta: Extension = {}) {\n    const { primary, type, unique = [], foreign, fields = {} } = meta\n    const table = config[name] ||= {\n      primary: 'id',\n      unique: [],\n      foreign: {},\n      fields: {},\n    }\n\n    table.type = type || table.type\n    table.primary = primary || table.primary\n    table.unique.push(...unique)\n    Object.assign(table.foreign, foreign)\n\n    for (const key in fields) {\n      table.fields[key] = Field.parse(fields[key])\n    }\n  }\n\n  export function create<T extends TableType>(name: T): Tables[T] {\n    const { fields, primary } = Tables.config[name]\n    const result = {} as Tables[T]\n    for (const key in fields) {\n      if (key !== primary && fields[key].initial !== undefined) {\n        result[key] = utils.clone(fields[key].initial)\n      }\n    }\n    return result\n  }\n\n  extend('user', {\n    type: 'incremental',\n    fields: {\n      id: 'string(63)',\n      name: 'string(63)',\n      flag: 'unsigned(20)',\n      authority: 'unsigned(4)',\n      usage: 'json',\n      timers: 'json',\n    },\n  })\n\n  extend('channel', {\n    fields: {\n      id: 'string(63)',\n      flag: 'unsigned(20)',\n      assignee: 'string(63)',\n      disable: 'list',\n    },\n  })\n}\n\nexport type Query<T extends TableType> = Query.Expr<Tables[T]> | Query.Shorthand<Primitive>\n\nexport namespace Query {\n  export type Field<T extends TableType> = string & keyof Tables[T]\n  export type Index<T extends TableType> = Keys<Tables[T], Primitive>\n\n  export interface FieldExpr<T = any> {\n    $in?: Extract<T, Primitive, T[]>\n    $nin?: Extract<T, Primitive, T[]>\n    $eq?: Extract<T, Comparable>\n    $ne?: Extract<T, Comparable>\n    $gt?: Extract<T, Comparable>\n    $gte?: Extract<T, Comparable>\n    $lt?: Extract<T, Comparable>\n    $lte?: Extract<T, Comparable>\n    $el?: T extends (infer U)[] ? FieldQuery<U> : never\n    $size?: Extract<T, any[], number>\n    $regex?: Extract<T, string, RegExp>\n    $regexFor?: Extract<T, string>\n    $bitsAllClear?: Extract<T, number>\n    $bitsAllSet?: Extract<T, number>\n    $bitsAnyClear?: Extract<T, number>\n    $bitsAnySet?: Extract<T, number>\n  }\n\n  export interface LogicalExpr<T = any> {\n    $or?: Expr<T>[]\n    $and?: Expr<T>[]\n    $not?: Expr<T>\n    $expr?: Eval.Boolean<T>\n  }\n\n  export type Shorthand<T = any> =\n    | Extract<T, Comparable>\n    | Extract<T, Primitive, T[]>\n    | Extract<T, string, RegExp>\n\n  export type FieldQuery<T = any> = FieldExpr<T> | Shorthand<T>\n  export type Expr<T = any> = LogicalExpr<T> & {\n    [K in keyof T]?: FieldQuery<T[K]>\n  }\n\n  export function resolve<T extends TableType>(name: T, query: Query<T> = {}): Expr<Tables[T]> {\n    if (Array.isArray(query) || query instanceof RegExp || ['string', 'number'].includes(typeof query)) {\n      const { primary } = Tables.config[name]\n      return { [primary]: query } as any\n    }\n    return query as any\n  }\n\n  export interface ModifierExpr<K extends string> {\n    limit?: number\n    offset?: number\n    fields?: K[]\n  }\n\n  export type Modifier<T extends string> = T[] | ModifierExpr<T>\n\n  export function resolveModifier<K extends string>(modifier: Modifier<K>): ModifierExpr<K> {\n    if (Array.isArray(modifier)) return { fields: modifier }\n    return modifier || {}\n  }\n\n  type Projection<T extends TableType> = Record<string, Eval.Aggregation<Tables[T]>>\n\n  type MapEval<T, P> = {\n    [K in keyof P]: Eval<T, P[K]>\n  }\n\n  export interface Database {\n    drop(table?: TableType): Promise<void>\n    get<T extends TableType, K extends Field<T>>(table: T, query: Query<T>, modifier?: Modifier<K>): Promise<Pick<Tables[T], K>[]>\n    remove<T extends TableType>(table: T, query: Query<T>): Promise<void>\n    create<T extends TableType>(table: T, data: Partial<Tables[T]>): Promise<Tables[T]>\n    update<T extends TableType>(table: T, data: Partial<Tables[T]>[], key?: Index<T>): Promise<void>\n    aggregate<T extends TableType, P extends Projection<T>>(table: T, fields: P, query?: Query<T>): Promise<MapEval<T, P>>\n  }\n}\n\nexport type Eval<T, U> =\n  | U extends number ? number\n  : U extends boolean ? boolean\n  : U extends string ? Get<T, U>\n  : U extends Eval.NumericExpr ? number\n  : U extends Eval.BooleanExpr ? boolean\n  : U extends Eval.AggregationExpr ? number\n  : never\n\nexport namespace Eval {\n  export type Any<T = any, A = never> = A | number | boolean | Keys<T> | NumericExpr<T, A> | BooleanExpr<T, A>\n  export type GeneralExpr = NumericExpr & BooleanExpr & AggregationExpr\n  export type Numeric<T = any, A = never> = A | number | Keys<T, number> | NumericExpr<T, A>\n  export type Boolean<T = any, A = never> = boolean | Keys<T, boolean> | BooleanExpr<T, A>\n  export type Aggregation<T = any> = Any<{}, AggregationExpr<T>>\n\n  export interface NumericExpr<T = any, A = never> {\n    $add?: Numeric<T, A>[]\n    $multiply?: Numeric<T, A>[]\n    $subtract?: [Numeric<T, A>, Numeric<T, A>]\n    $divide?: [Numeric<T, A>, Numeric<T, A>]\n  }\n\n  export interface BooleanExpr<T = any, A = never> {\n    $eq?: [Numeric<T, A>, Numeric<T, A>]\n    $ne?: [Numeric<T, A>, Numeric<T, A>]\n    $gt?: [Numeric<T, A>, Numeric<T, A>]\n    $gte?: [Numeric<T, A>, Numeric<T, A>]\n    $lt?: [Numeric<T, A>, Numeric<T, A>]\n    $lte?: [Numeric<T, A>, Numeric<T, A>]\n  }\n\n  export interface AggregationExpr<T = any> {\n    $sum?: Any<T>\n    $avg?: Any<T>\n    $max?: Any<T>\n    $min?: Any<T>\n    $count?: Any<T>\n  }\n}\n\nexport interface User extends Record<Platform, string> {\n  id: string\n  flag: number\n  authority: number\n  name: string\n  usage: Record<string, number>\n  timers: Record<string, number>\n}\n\nexport namespace User {\n  export enum Flag {\n    ignore = 1,\n  }\n\n  export type Field = keyof User\n  export const fields: Field[] = []\n  export type Index = Platform | 'name' | 'id'\n  export type Observed<K extends Field = Field> = utils.Observed<Pick<User, K>, Promise<void>>\n  type Getter = <T extends Index>(type: T, id: string) => Partial<User>\n  const getters: Getter[] = []\n\n  /**\n   * @deprecated use `Tables.extend('user', { fields })` instead\n   */\n  export function extend(getter: Getter) {\n    getters.push(getter)\n    fields.push(...Object.keys(getter(null as never, '0')) as any)\n  }\n\n  export function create<T extends Index>(type: T, id: string) {\n    const result = Tables.create('user')\n    result[type] = id\n    for (const getter of getters) {\n      Object.assign(result, getter(type, id))\n    }\n    return result as User\n  }\n\n  export interface Database {\n    getUser<K extends Field, T extends Index>(type: T, id: string, modifier?: Query.Modifier<K>): Promise<Pick<User, K | T>>\n    getUser<K extends Field, T extends Index>(type: T, ids: string[], modifier?: Query.Modifier<K>): Promise<Pick<User, K>[]>\n    getUser<K extends Field, T extends Index>(type: T, id: MaybeArray<string>, modifier?: Query.Modifier<K>): Promise<any>\n    setUser<T extends Index>(type: T, id: string, data: Partial<User>): Promise<void>\n    createUser<T extends Index>(type: T, id: string, data: Partial<User>): Promise<void>\n  }\n}\n\nexport interface Channel {\n  id: string\n  flag: number\n  assignee: string\n  disable: string[]\n}\n\nexport namespace Channel {\n  export enum Flag {\n    ignore = 1,\n    silent = 4,\n  }\n\n  export type Field = keyof Channel\n  export const fields: Field[] = []\n  export type Observed<K extends Field = Field> = utils.Observed<Pick<Channel, K>, Promise<void>>\n  type Getter = (type: Platform, id: string) => Partial<Channel>\n  const getters: Getter[] = []\n\n  /**\n   * @deprecated use `Tables.extend('user', { fields })` instead\n   */\n  export function extend(getter: Getter) {\n    getters.push(getter)\n    fields.push(...Object.keys(getter(null as never, '')) as any)\n  }\n\n  export function create(type: Platform, id: string) {\n    const result = Tables.create('channel')\n    result.id = `${type}:${id}`\n    for (const getter of getters) {\n      Object.assign(result, getter(type, id))\n    }\n    return result\n  }\n\n  export interface Database {\n    getChannel<K extends Field>(type: Platform, id: string, modifier?: Query.Modifier<K>): Promise<Pick<Channel, K | 'id'>>\n    getChannel<K extends Field>(type: Platform, ids: readonly string[], modifier?: Query.Modifier<K>): Promise<Pick<Channel, K>[]>\n    getChannel<K extends Field>(type: Platform, id: MaybeArray<string>, modifier?: Query.Modifier<K>): Promise<any>\n    getAssignedChannels<K extends Field>(fields?: K[], assignMap?: Record<string, readonly string[]>): Promise<Pick<Channel, K>[]>\n    setChannel(type: Platform, id: string, data: Partial<Channel>): Promise<void>\n    createChannel(type: Platform, id: string, data: Partial<Channel>): Promise<void>\n  }\n}\n\nexport interface Database extends Query.Database, User.Database, Channel.Database {}\n\ntype Methods<S, T> = {\n  [K in keyof S]?: S[K] extends (...args: infer R) => infer U ? (this: T, ...args: R) => U : S[K]\n}\n\nexport namespace Database {\n  export interface Statics {}\n\n  type Constructor<T> = new (...args: any[]) => T\n  type ExtensionMethods<T> = Methods<Database, T extends Constructor<infer I> ? I : never>\n  type Extension<T> = ((Database: T) => void) | ExtensionMethods<T>\n\n  export function extend<K extends keyof Statics>(module: K, extension: Extension<Statics[K]>): void\n  export function extend<T extends Constructor<unknown>>(module: T, extension: Extension<T>): void\n  export function extend(module: any, extension: any) {\n    let Database: any\n    try {\n      Database = typeof module === 'string' ? require(module).default : module\n    } catch (error) {\n      return\n    }\n\n    if (typeof extension === 'function') {\n      extension(Database)\n    } else {\n      Object.assign(Database.prototype, extension)\n    }\n  }\n}\n\nexport interface Assets {\n  types: readonly Assets.Type[]\n  upload(url: string, file: string): Promise<string>\n  stats(): Promise<Assets.Stats>\n}\n\nexport namespace Assets {\n  export type Type = 'image' | 'audio' | 'video' | 'file'\n\n  export interface Stats {\n    assetCount?: number\n    assetSize?: number\n  }\n}\n", "import { Logger, coerce, Time, template, remove, Awaitable } from 'koishi-utils'\nimport { Argv } from './parser'\nimport { Context, Disposable, NextFunction } from './context'\nimport { User, Channel } from './database'\nimport { FieldCollector, Session } from './session'\nimport { inspect, format } from 'util'\n\nconst logger = new Logger('command')\n\nexport type UserType<T, U extends User.Field = User.Field> = T | ((user: Pick<User, U>) => T)\n\nexport type Extend<O extends {}, K extends string, T> = {\n  [P in K | keyof O]?: (P extends keyof O ? O[P] : unknown) & (P extends K ? T : unknown)\n}\n\nexport namespace Command {\n  export interface Config {\n    /** hide all options by default */\n    hideOptions?: boolean\n    /** hide command */\n    hidden?: boolean\n    /** min authority */\n    authority?: number\n    /** disallow unknown options */\n    checkUnknown?: boolean\n    /** check argument count */\n    checkArgCount?: boolean\n    /** show command warnings */\n    showWarning?: boolean\n    /** usage identifier */\n    usageName?: string\n    /** max usage per day */\n    maxUsage?: UserType<number>\n    /** min interval */\n    minInterval?: UserType<number>\n    /** depend on existing commands */\n    patch?: boolean\n  }\n\n  export interface Shortcut {\n    name?: string | RegExp\n    command?: Command\n    authority?: number\n    prefix?: boolean\n    fuzzy?: boolean\n    args?: string[]\n    options?: Record<string, any>\n  }\n\n  export type Action<U extends User.Field = never, G extends Channel.Field = never, A extends any[] = any[], O extends {} = {}>\n    = (argv: Argv<U, G, A, O>, ...args: A) => Awaitable<void | string>\n\n  export type Usage<U extends User.Field = never, G extends Channel.Field = never>\n    = string | ((session: Session<U, G>) => Awaitable<string>)\n}\n\nexport class Command<U extends User.Field = never, G extends Channel.Field = never, A extends any[] = any[], O extends {} = {}> extends Argv.CommandBase {\n  config: Command.Config\n  children: Command[] = []\n  parent: Command = null\n\n  _aliases: string[] = []\n  _examples: string[] = []\n  _usage?: Command.Usage\n  _disposed?: boolean\n  _disposables?: Disposable[]\n\n  private _userFields: FieldCollector<'user'>[] = []\n  private _channelFields: FieldCollector<'channel'>[] = []\n  private _actions: Command.Action<U, G, A, O>[] = []\n  private _checkers: Command.Action<U, G, A, O>[] = []\n\n  static defaultConfig: Command.Config = {\n    authority: 1,\n    showWarning: true,\n    maxUsage: Infinity,\n    minInterval: 0,\n  }\n\n  static defaultOptionConfig: Argv.OptionConfig = {\n    authority: 0,\n  }\n\n  private static _userFields: FieldCollector<'user'>[] = []\n  private static _channelFields: FieldCollector<'channel'>[] = []\n\n  static userFields(fields: FieldCollector<'user'>) {\n    this._userFields.push(fields)\n    return this\n  }\n\n  static channelFields(fields: FieldCollector<'channel'>) {\n    this._channelFields.push(fields)\n    return this\n  }\n\n  constructor(name: string, decl: string, desc: string, public context: Context) {\n    super(name, decl, desc)\n    this.config = { ...Command.defaultConfig }\n    this._registerAlias(this.name)\n    context.app._commandList.push(this)\n    context.app.emit('command-added', this)\n  }\n\n  get app() {\n    return this.context.app\n  }\n\n  private _registerAlias(name: string) {\n    name = name.toLowerCase()\n    this._aliases.push(name)\n    const previous = this.app._commands.get(name)\n    if (!previous) {\n      this.app._commands.set(name, this)\n    } else if (previous !== this) {\n      throw new Error(format('duplicate command names: \"%s\"', name))\n    }\n  }\n\n  [inspect.custom]() {\n    return `Command <${this.name}>`\n  }\n\n  userFields<T extends User.Field = never>(fields: FieldCollector<'user', T, A, O>): Command<U | T, G, A, O> {\n    this._userFields.push(fields)\n    return this as any\n  }\n\n  channelFields<T extends Channel.Field = never>(fields: FieldCollector<'channel', T, A, O>): Command<U, G | T, A, O> {\n    this._channelFields.push(fields)\n    return this as any\n  }\n\n  alias(...names: string[]) {\n    if (this._disposed) return this\n    for (const name of names) {\n      this._registerAlias(name)\n      this._disposables?.push(() => {\n        remove(this._aliases, name)\n        this.app._commands.delete(name)\n      })\n    }\n    return this\n  }\n\n  shortcut(name: string | RegExp, config: Command.Shortcut = {}) {\n    if (this._disposed) return this\n    config.name = name\n    config.command = this\n    config.authority ||= this.config.authority\n    this.app._shortcuts.push(config)\n    this._disposables?.push(() => remove(this.app._shortcuts, config))\n    return this\n  }\n\n  subcommand<D extends string>(def: D, config?: Command.Config): Command<never, never, Argv.ArgumentType<D>>\n  subcommand<D extends string>(def: D, desc: string, config?: Command.Config): Command<never, never, Argv.ArgumentType<D>>\n  subcommand(def: string, ...args: any[]) {\n    def = this.name + (def.charCodeAt(0) === 46 ? '' : '/') + def\n    const desc = typeof args[0] === 'string' ? args.shift() as string : ''\n    const config = args[0] as Command.Config || {}\n    if (this._disposed) config.patch = true\n    return this.context.command(def, desc, config)\n  }\n\n  usage(text: Command.Usage<U, G>) {\n    this._usage = text\n    return this\n  }\n\n  example(example: string) {\n    this._examples.push(example)\n    return this\n  }\n\n  option<K extends string>(name: K, desc: string, config: Argv.TypedOptionConfig<RegExp>): Command<U, G, A, Extend<O, K, string>>\n  option<K extends string, R>(name: K, desc: string, config: Argv.TypedOptionConfig<(source: string) => R>): Command<U, G, A, Extend<O, K, R>>\n  option<K extends string, R extends string>(name: K, desc: string, config: Argv.TypedOptionConfig<R[]>): Command<U, G, A, Extend<O, K, R>>\n  option<K extends string, D extends string>(name: K, desc: D, config?: Argv.OptionConfig): Command<U, G, A, Extend<O, K, Argv.OptionType<D>>>\n  option(name: string, desc: string, config: Argv.OptionConfig = {}) {\n    this._createOption(name, desc, config)\n    this._disposables?.push(() => this.removeOption(name))\n    return this\n  }\n\n  match(session: Session) {\n    const { authority = Infinity } = (session.user || {}) as User\n    const { disable = [] } = (session.channel || {}) as Channel\n    return this.context.match(session) && this.config.authority <= authority && !disable.includes(this.name)\n  }\n\n  getConfig<K extends keyof Command.Config>(key: K, session: Session): Exclude<Command.Config[K], (user: User) => any> {\n    const value = this.config[key] as any\n    return typeof value === 'function' ? value(session.user) : value\n  }\n\n  check(callback: Command.Action<U, G, A, O>, prepend = false) {\n    if (prepend) {\n      this._checkers.unshift(callback)\n    } else {\n      this._checkers.push(callback)\n    }\n    this._disposables?.push(() => remove(this._checkers, callback))\n    return this\n  }\n\n  action(callback: Command.Action<U, G, A, O>, append = false) {\n    if (append) {\n      this._actions.push(callback)\n    } else {\n      this._actions.unshift(callback)\n    }\n    this._disposables?.push(() => remove(this._actions, callback))\n    return this\n  }\n\n  async execute(argv0: Argv<U, G, A, O>, next: NextFunction = fallback => fallback?.()): Promise<string> {\n    const argv = argv0 as Argv<U, G, A, O>\n    if (!argv.args) argv.args = [] as any\n    if (!argv.options) argv.options = {} as any\n\n    // bypass next function\n    let state = 'before command'\n    argv.next = async (fallback) => {\n      const oldState = state\n      state = ''\n      await next(fallback)\n      state = oldState\n    }\n\n    const { args, options, session, error } = argv\n    if (error) return error\n    if (logger.level >= 3) logger.debug(argv.source ||= this.stringify(args, options))\n    const lastCall = this.app.options.prettyErrors && new Error().stack.split('\\n', 4)[3]\n    try {\n      for (const validator of this._checkers) {\n        const result = await validator.call(this, argv, ...args)\n        if (typeof result === 'string') return result\n      }\n      const result = await this.app.serial(session, 'before-command', argv)\n      if (typeof result === 'string') return result\n      state = 'executing command'\n      for (const action of this._actions) {\n        const result = await action.call(this, argv, ...args)\n        if (typeof result === 'string') return result\n      }\n      state = 'after command'\n      await this.app.parallel(session, 'command', argv)\n      return ''\n    } catch (error) {\n      if (!state) throw error\n      let stack = coerce(error)\n      if (lastCall) {\n        const index = error.stack.indexOf(lastCall)\n        stack = stack.slice(0, index - 1)\n      }\n      logger.warn(`${state}: ${argv.source ||= this.stringify(args, options)}\\n${stack}`)\n      return ''\n    }\n  }\n\n  dispose() {\n    this._disposed = true\n    this.app.emit('command-removed', this)\n    for (const cmd of this.children.slice()) {\n      cmd.dispose()\n    }\n    this.app._shortcuts = this.app._shortcuts.filter(s => s.command !== this)\n    this._aliases.forEach(name => this.app._commands.delete(name))\n    remove(this.app._commandList, this)\n    if (this.parent) {\n      remove(this.parent.children, this)\n    }\n  }\n}\n\nexport function getUsageName(command: Command) {\n  return command.config.usageName || command.name\n}\n\nexport type ValidationField = 'authority' | 'usage' | 'timers'\n\nCommand.channelFields(['disable'])\n\nCommand.userFields(({ tokens, command, options = {} }, fields) => {\n  if (!command) return\n  const { maxUsage, minInterval, authority } = command.config\n  let shouldFetchAuthority = authority > 0\n  let shouldFetchUsage = !!(maxUsage || minInterval)\n  for (const { name, authority, notUsage } of Object.values(command._options)) {\n    if (name in options) {\n      if (authority > 0) shouldFetchAuthority = true\n      if (notUsage) shouldFetchUsage = false\n    } else if (tokens) {\n      if (authority > 0) shouldFetchAuthority = true\n    }\n  }\n  if (shouldFetchAuthority) fields.add('authority')\n  if (shouldFetchUsage) {\n    if (maxUsage) fields.add('usage')\n    if (minInterval) fields.add('timers')\n  }\n})\n\nexport default function apply(ctx: Context) {\n  // check channel\n  ctx.before('command', ({ session, command }: Argv<never, 'disable'>) => {\n    if (!session.channel) return\n    while (command) {\n      if (session.channel.disable.includes(command.name)) return ''\n      command = command.parent as any\n    }\n  })\n\n  // check user\n  ctx.before('command', (argv: Argv<ValidationField>) => {\n    const { session, options, command } = argv\n    if (!session.user) return\n\n    function sendHint(message: string, ...param: any[]) {\n      return command.config.showWarning ? template(message, param) : ''\n    }\n\n    let isUsage = true\n\n    // check authority\n    if (command.config.authority > session.user.authority) {\n      return sendHint('internal.low-authority')\n    }\n    for (const option of Object.values(command._options)) {\n      if (option.name in options) {\n        if (option.authority > session.user.authority) {\n          return sendHint('internal.low-authority')\n        }\n        if (option.notUsage) isUsage = false\n      }\n    }\n\n    // check usage\n    if (isUsage) {\n      const name = getUsageName(command)\n      const minInterval = command.getConfig('minInterval', session)\n      const maxUsage = command.getConfig('maxUsage', session)\n\n      if (maxUsage < Infinity && checkUsage(name, session.user, maxUsage)) {\n        return sendHint('internal.usage-exhausted')\n      }\n\n      if (minInterval > 0 && checkTimer(name, session.user, minInterval)) {\n        return sendHint('internal.too-frequent')\n      }\n    }\n  })\n\n  // check argv\n  ctx.before('command', (argv: Argv) => {\n    const { args, options, command } = argv\n    function sendHint(message: string, ...param: any[]) {\n      return command.config.showWarning ? template(message, param) : ''\n    }\n\n    // check argument count\n    if (command.config.checkArgCount) {\n      const nextArg = command._arguments[args.length] || {}\n      if (nextArg.required) {\n        return sendHint('internal.insufficient-arguments')\n      }\n      const finalArg = command._arguments[command._arguments.length - 1] || {}\n      if (args.length > command._arguments.length && finalArg.type !== 'text' && !finalArg.variadic) {\n        return sendHint('internal.redunant-arguments')\n      }\n    }\n\n    // check unknown options\n    if (command.config.checkUnknown) {\n      const unknown = Object.keys(options).filter(key => !command._options[key])\n      if (unknown.length) {\n        return sendHint('internal.unknown-option', unknown.join(', '))\n      }\n    }\n  })\n}\n\nexport function getUsage(name: string, user: Pick<User, 'usage'>) {\n  const $date = Time.getDateNumber()\n  if (user.usage.$date !== $date) {\n    user.usage = { $date }\n  }\n  return user.usage[name] || 0\n}\n\nexport function checkUsage(name: string, user: Pick<User, 'usage'>, maxUsage?: number) {\n  if (!user.usage) return\n  const count = getUsage(name, user)\n  if (count >= maxUsage) return true\n  if (maxUsage) {\n    user.usage[name] = count + 1\n  }\n}\n\nexport function checkTimer(name: string, { timers }: Pick<User, 'timers'>, offset?: number) {\n  const now = Date.now()\n  if (!(now <= timers.$date)) {\n    for (const key in timers) {\n      if (now > timers[key]) delete timers[key]\n    }\n    timers.$date = now + Time.day\n  }\n  if (now <= timers[name]) return true\n  if (offset !== undefined) {\n    timers[name] = now + offset\n  }\n}\n", "import { camelCase, segment, escapeRegExp, paramCase, template, Time } from 'koishi-utils'\nimport { format } from 'util'\nimport { Platform } from './adapter'\nimport { Command } from './command'\nimport { NextFunction } from './context'\nimport { Channel, User } from './database'\nimport { Session } from './session'\n\nexport interface Token {\n  rest?: string\n  content: string\n  quoted: boolean\n  terminator: string\n  inters: Argv[]\n}\n\nexport interface Argv<U extends User.Field = never, G extends Channel.Field = never, A extends any[] = any[], O = {}> {\n  args?: A\n  options?: O\n  error?: string\n  source?: string\n  initiator?: string\n  terminator?: string\n  session?: Session<U, G>\n  command?: Command<U, G, A, O>\n  rest?: string\n  pos?: number\n  root?: boolean\n  tokens?: Token[]\n  name?: string\n  next?: NextFunction\n}\n\nconst leftQuotes = `\"'“‘`\nconst rightQuotes = `\"'”’`\n\nexport namespace Argv {\n  export interface Interpolation {\n    terminator?: string\n    parse?(source: string): Argv\n  }\n\n  const bracs: Record<string, Interpolation> = {}\n\n  export function interpolate(initiator: string, terminator: string, parse?: (source: string) => Argv) {\n    bracs[initiator] = { terminator, parse }\n  }\n\n  interpolate('$(', ')')\n\n  export class Tokenizer {\n    private bracs: Record<string, Interpolation>\n\n    constructor() {\n      this.bracs = Object.create(bracs)\n    }\n\n    interpolate(initiator: string, terminator: string, parse?: (source: string) => Argv) {\n      this.bracs[initiator] = { terminator, parse }\n    }\n\n    parseToken(source: string, stopReg = '$'): Token {\n      const parent = { inters: [] } as Token\n      const index = leftQuotes.indexOf(source[0])\n      const quote = rightQuotes[index]\n      let content = ''\n      if (quote) {\n        source = source.slice(1)\n        stopReg = `${quote}(?=${stopReg})|$`\n      }\n      stopReg += `|${Object.keys({ ...this.bracs, ...bracs }).map(escapeRegExp).join('|')}`\n      const regExp = new RegExp(stopReg)\n      while (true) {\n        const capture = regExp.exec(source)\n        content += source.slice(0, capture.index)\n        if (capture[0] in this.bracs) {\n          source = source.slice(capture.index + capture[0].length).trimStart()\n          const { parse, terminator } = this.bracs[capture[0]]\n          const argv = parse?.(source) || this.parse(source, terminator)\n          source = argv.rest\n          parent.inters.push({ ...argv, pos: content.length, initiator: capture[0] })\n        } else {\n          const quoted = capture[0] === quote\n          const rest = source.slice(capture.index + +quoted)\n          parent.rest = rest.trimStart()\n          parent.quoted = quoted\n          parent.terminator = capture[0]\n          if (quoted) {\n            parent.terminator += rest.slice(0, -parent.rest.length)\n          } else if (quote) {\n            content = leftQuotes[index] + content\n            parent.inters.forEach(inter => inter.pos += 1)\n          }\n          parent.content = content\n          if (quote === \"'\") Argv.revert(parent)\n          return parent\n        }\n      }\n    }\n\n    parse(source: string, terminator = ''): Argv {\n      const tokens: Token[] = []\n      let rest = source, term = ''\n      const stopReg = `\\\\s+|[${escapeRegExp(terminator)}]|$`\n      // eslint-disable-next-line no-unmodified-loop-condition\n      while (rest && !(terminator && rest.startsWith(terminator))) {\n        const token = this.parseToken(rest, stopReg)\n        tokens.push(token)\n        rest = token.rest\n        term = token.terminator\n        delete token.rest\n      }\n      if (rest.startsWith(terminator)) rest = rest.slice(1)\n      source = source.slice(0, -(rest + term).length)\n      return { tokens, rest, source }\n    }\n\n    stringify(argv: Argv) {\n      const output = argv.tokens.reduce((prev, token) => {\n        if (token.quoted) prev += leftQuotes[rightQuotes.indexOf(token.terminator[0])]\n        return prev + token.content + token.terminator\n      }, '')\n      if (argv.rest && !rightQuotes.includes(output[output.length - 1]) || argv.initiator) {\n        return output.slice(0, -1)\n      }\n      return output\n    }\n  }\n\n  const defaultTokenizer = new Tokenizer()\n\n  export function parse(source: string, terminator = '') {\n    return defaultTokenizer.parse(source, terminator)\n  }\n\n  export function stringify(argv: Argv) {\n    return defaultTokenizer.stringify(argv)\n  }\n\n  export function revert(token: Token) {\n    while (token.inters.length) {\n      const { pos, source, initiator } = token.inters.pop()\n      token.content = token.content.slice(0, pos)\n        + initiator + source + bracs[initiator].terminator\n        + token.content.slice(pos)\n    }\n  }\n\n  export function parsePid(target: string): [Platform, string] {\n    const index = target.indexOf(':')\n    const platform = target.slice(0, index)\n    const id = target.slice(index + 1)\n    return [platform, id] as any\n  }\n\n  // builtin domains\n  export interface Domain {\n    string: string\n    number: number\n    boolean: boolean\n    text: string\n    rawtext: string\n    user: string\n    channel: string\n    integer: number\n    posint: number\n    natural: number\n    date: Date\n  }\n\n  type DomainType = keyof Domain\n\n  type ParamType<S extends string, F>\n    = S extends `${any}:${infer T}` ? T extends DomainType ? Domain[T] : F : F\n\n  type Replace<S extends string, X extends string, Y extends string>\n    = S extends `${infer L}${X}${infer R}` ? `${L}${Y}${Replace<R, X, Y>}` : S\n\n  type ExtractAll<S extends string, F>\n    = S extends `${infer L}]${infer R}` ? [ParamType<L, F>, ...ExtractAll<R, F>] : []\n\n  type ExtractFirst<S extends string, F>\n    = S extends `${infer L}]${any}` ? ParamType<L, F> : boolean\n\n  type ExtractSpread<S extends string> = S extends `${infer L}...${infer R}`\n    ? [...ExtractAll<L, string>, ...ExtractFirst<R, string>[]]\n    : [...ExtractAll<S, string>, ...string[]]\n\n  export type ArgumentType<S extends string> = ExtractSpread<Replace<S, '>', ']'>>\n\n  export type OptionType<S extends string> = ExtractFirst<Replace<S, '>', ']'>, any>\n\n  export type Type = DomainType | RegExp | string[] | Transform<any>\n\n  export interface Declaration {\n    name?: string\n    type?: Type\n    fallback?: any\n    variadic?: boolean\n    required?: boolean\n  }\n\n  export type Transform<T> = (source: string, session: Session) => T\n\n  export interface DomainConfig<T> {\n    transform?: Transform<T>\n    greedy?: boolean\n  }\n\n  function resolveConfig(type: Type) {\n    return typeof type === 'string' ? builtin[type] || {} : {}\n  }\n\n  function resolveType(type: Type) {\n    if (typeof type === 'function') {\n      return type\n    } else if (type instanceof RegExp) {\n      return (source: string) => {\n        if (type.test(source)) return source\n        throw new Error()\n      }\n    } else if (Array.isArray(type)) {\n      return (source: string) => {\n        if (type.includes(source)) return source\n        throw new Error()\n      }\n    }\n    return builtin[type]?.transform\n  }\n\n  const builtin: Record<string, DomainConfig<any>> = {}\n\n  export function createDomain<K extends keyof Domain>(name: K, transform: Transform<Domain[K]>, options?: DomainConfig<Domain[K]>) {\n    builtin[name] = { ...options, transform }\n  }\n\n  createDomain('rawtext', source => source)\n  createDomain('string', source => source)\n  createDomain('text', source => source, { greedy: true })\n  createDomain('rawtext', source => segment.unescape(source), { greedy: true })\n  createDomain('boolean', () => true)\n\n  createDomain('number', (source) => {\n    const value = +source\n    if (Number.isFinite(value)) return value\n    throw new Error(template('internal.invalid-number'))\n  })\n\n  createDomain('integer', (source) => {\n    const value = +source\n    if (value * 0 === 0 && Math.floor(value) === value) return value\n    throw new Error(template('internal.invalid-integer'))\n  })\n\n  createDomain('posint', (source) => {\n    const value = +source\n    if (value * 0 === 0 && Math.floor(value) === value && value > 0) return value\n    throw new Error(template('internal.invalid-posint'))\n  })\n\n  createDomain('natural', (source) => {\n    const value = +source\n    if (value * 0 === 0 && Math.floor(value) === value && value >= 0) return value\n    throw new Error(template('internal.invalid-natural'))\n  })\n\n  createDomain('date', (source) => {\n    const timestamp = Time.parseDate(source)\n    if (+timestamp) return timestamp\n    throw new Error(template('internal.invalid-date'))\n  })\n\n  createDomain('user', (source, session) => {\n    if (source.startsWith('@')) {\n      source = source.slice(1)\n      if (source.includes(':')) return source\n      return `${session.platform}:${source}`\n    }\n    const code = segment.from(source)\n    if (code && code.type === 'at') {\n      return `${session.platform}:${code.data.id}`\n    }\n    throw new Error(template('internal.invalid-user'))\n  })\n\n  createDomain('channel', (source, session) => {\n    if (source.startsWith('#')) {\n      source = source.slice(1)\n      if (source.includes(':')) return source\n      return `${session.platform}:${source}`\n    }\n    const code = segment.from(source)\n    if (code && code.type === 'sharp') {\n      return `${session.platform}:${code.data.id}`\n    }\n    throw new Error(template('internal.invalid-channel'))\n  })\n\n  const BRACKET_REGEXP = /<[^>]+>|\\[[^\\]]+\\]/g\n\n  interface DeclarationList extends Array<Declaration> {\n    stripped: string\n  }\n\n  function parseDecl(source: string) {\n    let cap: RegExpExecArray\n    const result = [] as DeclarationList\n    // eslint-disable-next-line no-cond-assign\n    while (cap = BRACKET_REGEXP.exec(source)) {\n      let rawName = cap[0].slice(1, -1)\n      let variadic = false\n      if (rawName.startsWith('...')) {\n        rawName = rawName.slice(3)\n        variadic = true\n      }\n      const [name, rawType] = rawName.split(':')\n      const type = rawType ? rawType.trim() as DomainType : undefined\n      result.push({\n        name,\n        variadic,\n        type,\n        required: cap[0][0] === '<',\n      })\n    }\n    result.stripped = source.replace(/:[\\w-]+[>\\]]/g, str => str.slice(-1)).trimEnd()\n    return result\n  }\n\n  export function parseValue(source: string, quoted: boolean, kind: string, argv: Argv, decl: Declaration = {}) {\n    const { name, type, fallback } = decl\n\n    // no explicit parameter & has fallback\n    const implicit = source === '' && !quoted\n    if (implicit && fallback !== undefined) return fallback\n\n    // apply domain callback\n    const transform = resolveType(type)\n    if (transform) {\n      try {\n        return transform(source, argv.session)\n      } catch (err) {\n        const message = err['message'] || template('internal.check-syntax')\n        argv.error = template(`internal.invalid-${kind}`, name, message)\n        return\n      }\n    }\n\n    // default behavior\n    if (implicit) return true\n    if (quoted) return source\n    const n = +source\n    return n * 0 === 0 ? n : source\n  }\n\n  export interface OptionConfig<T extends Type = Type> {\n    value?: any\n    fallback?: any\n    type?: T\n    /** hide the option by default */\n    hidden?: boolean | ((session: Session) => boolean)\n    authority?: number\n    notUsage?: boolean\n  }\n\n  export interface TypedOptionConfig<T extends Type> extends OptionConfig<T> {\n    type: T\n  }\n\n  export interface OptionDeclaration extends Declaration, OptionConfig {\n    description?: string\n    values?: Record<string, any>\n  }\n\n  type OptionDeclarationMap = Record<string, OptionDeclaration>\n\n  export class CommandBase {\n    public declaration: string\n\n    public _arguments: Declaration[]\n    public _options: OptionDeclarationMap = {}\n\n    private _namedOptions: OptionDeclarationMap = {}\n    private _symbolicOptions: OptionDeclarationMap = {}\n\n    constructor(public name: string, declaration: string, public description: string) {\n      if (!name) throw new Error('expect a command name')\n      const decl = this._arguments = parseDecl(declaration)\n      this.declaration = decl.stripped\n    }\n\n    _createOption(name: string, def: string, config: OptionConfig) {\n      const param = paramCase(name)\n      const decl = def.replace(/(?<=^|\\s)[\\w\\x80-\\uffff].*/, '')\n      const desc = def.slice(decl.length)\n      let syntax = decl.replace(/(?<=^|\\s)(<[^<]+>|\\[[^[]+\\]).*/, '')\n      const bracket = decl.slice(syntax.length)\n      syntax = syntax.trim() || '--' + param\n\n      const names: string[] = []\n      const symbols: string[] = []\n      for (let param of syntax.trim().split(',')) {\n        param = param.trimStart()\n        const name = param.replace(/^-+/, '')\n        if (!name || !param.startsWith('-')) {\n          symbols.push(param)\n        } else {\n          names.push(name)\n        }\n      }\n\n      if (!config.value && !names.includes(param)) {\n        syntax += ', --' + param\n      }\n\n      const declList = parseDecl(bracket)\n      if (declList.stripped) syntax += ' ' + declList.stripped\n      if (desc) syntax += '  ' + desc\n      const option = this._options[name] ||= {\n        ...Command.defaultOptionConfig,\n        ...declList[0],\n        ...config,\n        name,\n        values: {},\n        description: syntax,\n      }\n\n      const fallbackType = typeof option.fallback\n      if ('value' in config) {\n        names.forEach(name => option.values[name] = config.value)\n      } else if (!bracket.trim()) {\n        option.type = 'boolean'\n      } else if (!option.type && (fallbackType === 'string' || fallbackType === 'number')) {\n        option.type = fallbackType\n      }\n\n      this._assignOption(option, names, this._namedOptions)\n      this._assignOption(option, symbols, this._symbolicOptions)\n      if (!this._namedOptions[param]) {\n        this._namedOptions[param] = option\n      }\n    }\n\n    private _assignOption(option: OptionDeclaration, names: readonly string[], optionMap: OptionDeclarationMap) {\n      for (const name of names) {\n        if (name in optionMap) {\n          throw new Error(format('duplicate option name \"%s\" for command \"%s\"', name, this.name))\n        }\n        optionMap[name] = option\n      }\n    }\n\n    removeOption<K extends string>(name: K) {\n      if (!this._options[name]) return false\n      const option = this._options[name]\n      delete this._options[name]\n      for (const key in this._namedOptions) {\n        if (this._namedOptions[key] === option) {\n          delete this._namedOptions[key]\n        }\n      }\n      for (const key in this._symbolicOptions) {\n        if (this._symbolicOptions[key] === option) {\n          delete this._symbolicOptions[key]\n        }\n      }\n      return true\n    }\n\n    parse(argv: Argv): Argv\n    parse(source: string, terminator?: string, args?: any[], options?: Record<string, any>): Argv\n    parse(argv: string | Argv, terminator?: string, args = [], options = {}): Argv {\n      if (typeof argv === 'string') argv = Argv.parse(argv, terminator)\n\n      const source = this.name + ' ' + Argv.stringify(argv)\n      while (!argv.error && argv.tokens.length) {\n        const token = argv.tokens[0]\n        let { content, quoted } = token\n\n        // greedy argument\n        const argDecl = this._arguments[args.length]\n        if (content[0] !== '-' && resolveConfig(argDecl?.type).greedy) {\n          args.push(Argv.parseValue(Argv.stringify(argv), true, 'argument', argv, argDecl))\n          break\n        }\n\n        // parse token\n        argv.tokens.shift()\n        let option: OptionDeclaration\n        let names: string | string[]\n        let param: string\n        // symbolic option\n        if (!quoted && (option = this._symbolicOptions[content])) {\n          names = [paramCase(option.name)]\n        } else {\n          // normal argument\n          if (content[0] !== '-' || quoted) {\n            args.push(Argv.parseValue(content, quoted, 'argument', argv, argDecl || { type: 'string' }))\n            continue\n          }\n\n          // find -\n          let i = 0\n          let name: string\n          for (; i < content.length; ++i) {\n            if (content.charCodeAt(i) !== 45) break\n          }\n          if (content.slice(i, i + 3) === 'no-' && !this._namedOptions[content.slice(i)]) {\n            name = content.slice(i + 3)\n            options[camelCase(name)] = false\n            continue\n          }\n\n          // find =\n          let j = i + 1\n          for (; j < content.length; j++) {\n            if (content.charCodeAt(j) === 61) break\n          }\n          name = content.slice(i, j)\n          names = i > 1 ? [name] : name\n          param = content.slice(++j)\n          option = this._namedOptions[names[names.length - 1]]\n        }\n\n        // get parameter from next token\n        quoted = false\n        if (!param) {\n          const { type } = option || {}\n          if (resolveConfig(type).greedy) {\n            param = Argv.stringify(argv)\n            quoted = true\n            argv.tokens = []\n          } else if (type !== 'boolean' && argv.tokens.length && (type || argv.tokens[0]?.content !== '-')) {\n            const token = argv.tokens.shift()\n            param = token.content\n            quoted = token.quoted\n          }\n        }\n\n        // handle each name\n        for (let j = 0; j < names.length; j++) {\n          const name = names[j]\n          const optDecl = this._namedOptions[name]\n          const key = optDecl ? optDecl.name : camelCase(name)\n          if (optDecl && name in optDecl.values) {\n            options[key] = optDecl.values[name]\n          } else {\n            const source = j + 1 < names.length ? '' : param\n            options[key] = Argv.parseValue(source, quoted, 'option', argv, optDecl)\n          }\n          if (argv.error) break\n        }\n      }\n\n      // assign default values\n      for (const { name, fallback } of Object.values(this._options)) {\n        if (fallback !== undefined && !(name in options)) {\n          options[name] = fallback\n        }\n      }\n\n      delete argv.tokens\n      return { options, args, source, rest: argv.rest, error: argv.error || '' }\n    }\n\n    private stringifyArg(value: any) {\n      value = '' + value\n      return value.includes(' ') ? `\"${value}\"` : value\n    }\n\n    stringify(args: readonly string[], options: any) {\n      let output = this.name\n      for (const key in options) {\n        const value = options[key]\n        if (value === true) {\n          output += ` --${key}`\n        } else if (value === false) {\n          output += ` --no-${key}`\n        } else {\n          output += ` --${key} ${this.stringifyArg(value)}`\n        }\n      }\n      for (const arg of args) {\n        output += ' ' + this.stringifyArg(arg)\n      }\n      return output\n    }\n  }\n}\n", "import { simplify, defineProperty, Time, Observed, coerce, escapeRegExp, makeArray, template, trimSlash, merge } from 'koishi-utils'\nimport { Context, Middleware, NextFunction, Plugin } from './context'\nimport { Argv } from './parser'\nimport { BotOptions, Adapter, createBots } from './adapter'\nimport { Channel, User } from './database'\nimport validate, { Command } from './command'\nimport { Session } from './session'\nimport help, { getCommandNames, HelpConfig } from './help'\nimport LruCache from 'lru-cache'\nimport { AxiosRequestConfig } from 'axios'\nimport { Server, createServer } from 'http'\nimport type Koa from 'koa'\n\nexport interface DelayOptions {\n  character?: number\n  message?: number\n  cancel?: number\n  broadcast?: number\n  prompt?: number\n}\n\nexport interface AppOptions extends BotOptions {\n  port?: number\n  host?: string\n  bots?: BotOptions[]\n  prefix?: string | string[] | ((session: Session.Message) => void | string | string[])\n  nickname?: string | string[]\n  maxListeners?: number\n  prettyErrors?: boolean\n  processMessage?: (message: string) => string\n  delay?: DelayOptions\n  help?: boolean | HelpConfig\n  autoAssign?: boolean | ((session: Session) => boolean)\n  autoAuthorize?: number | ((session: Session) => number)\n  userCacheAge?: number\n  userCacheLength?: number\n  channelCacheLength?: number\n  channelCacheAge?: number\n  minSimilarity?: number\n  selfUrl?: string\n  axiosConfig?: AxiosRequestConfig\n}\n\nfunction createLeadingRE(patterns: string[], prefix = '', suffix = '') {\n  return patterns.length ? new RegExp(`^${prefix}(${patterns.map(escapeRegExp).join('|')})${suffix}`) : /$^/\n}\n\ninterface CommandMap extends Map<string, Command> {\n  resolve(key: string): Command\n}\n\nexport class App extends Context {\n  public app = this\n  public options: AppOptions\n  public status = App.Status.closed\n  public adapters: Adapter.Instances = {}\n  public registry = new Plugin.Registry()\n\n  _bots = createBots('sid')\n  _commandList: Command[] = []\n  _commands: CommandMap = new Map<string, Command>() as never\n  _shortcuts: Command.Shortcut[] = []\n  _hooks: Record<keyof any, [Context, (...args: any[]) => any][]> = {}\n  _userCache: Record<string, LruCache<string, Observed<Partial<User>, Promise<void>>>>\n  _channelCache: LruCache<string, Observed<Partial<Channel>, Promise<void>>>\n  _httpServer?: Server\n  _sessions: Record<string, Session> = {}\n\n  private _nameRE: RegExp\n\n  static defaultConfig: AppOptions = {\n    maxListeners: 64,\n    prettyErrors: true,\n    userCacheAge: Time.minute,\n    channelCacheAge: 5 * Time.minute,\n    autoAssign: true,\n    autoAuthorize: 1,\n    minSimilarity: 0.4,\n    processMessage: message => simplify(message.trim()),\n    delay: {\n      character: 0,\n      cancel: 0,\n      message: 0.1 * Time.second,\n      broadcast: 0.5 * Time.second,\n      prompt: Time.minute,\n    },\n  }\n\n  constructor(options: AppOptions = {}) {\n    super(() => true)\n    if (!options.bots) options.bots = [options]\n    if (options.selfUrl) options.selfUrl = trimSlash(options.selfUrl)\n    this.options = merge(options, App.defaultConfig)\n    this.registry.set(null, {\n      children: [],\n      disposables: [],\n    })\n\n    defineProperty(this, '_userCache', {})\n    defineProperty(this, '_channelCache', new LruCache({\n      max: options.channelCacheLength,\n      maxAge: options.channelCacheAge,\n    }))\n\n    if (options.port) this.createServer()\n    for (const bot of options.bots) {\n      Adapter.from(this, bot).create(bot)\n    }\n\n    this._commands.resolve = (key) => {\n      if (!key) return\n      const segments = key.split('.')\n      let i = 1, name = segments[0], cmd: Command\n      while ((cmd = this._commands.get(name)) && i < segments.length) {\n        name = cmd.name + '.' + segments[i++]\n      }\n      return cmd\n    }\n\n    this.prepare()\n\n    // bind built-in event listeners\n    this.middleware(this._process.bind(this))\n    this.middleware(this._suggest.bind(this))\n    this.on('message', this._handleMessage.bind(this))\n    this.before('parse', this._handleArgv.bind(this))\n    this.before('parse', this._handleShortcut.bind(this))\n    this.before('connect', this._listen.bind(this))\n    this.before('disconnect', this._close.bind(this))\n\n    this.on('parse', (argv: Argv, session: Session) => {\n      const { parsed, subtype } = session\n      // group message should have prefix or appel to be interpreted as a command call\n      if (argv.root && subtype !== 'private' && parsed.prefix === null && !parsed.appel) return\n      if (!argv.tokens.length) return\n      const cmd = this._commands.resolve(argv.tokens[0].content)\n      if (cmd) {\n        argv.tokens.shift()\n        return cmd.name\n      }\n    })\n\n    this.before('attach-user', (session, fields) => {\n      session.collect('user', session.argv, fields)\n    })\n\n    this.before('attach-channel', (session, fields) => {\n      session.collect('channel', session.argv, fields)\n    })\n\n    this.plugin(validate)\n    this.plugin(help, options.help)\n  }\n\n  createServer() {\n    const koa: Koa = new (require('koa'))()\n    this.router = new (require('@koa/router'))()\n    koa.use(require('koa-bodyparser')())\n    koa.use(this.router.routes())\n    koa.use(this.router.allowedMethods())\n    defineProperty(this, '_httpServer', createServer(koa.callback()))\n  }\n\n  prepare() {\n    const { nickname } = this.options\n    this.options.nickname = makeArray(nickname)\n    this._nameRE = createLeadingRE(this.options.nickname, '@?', '([,，]\\\\s*|\\\\s+)')\n  }\n\n  async start() {\n    this.status = App.Status.opening\n    await this.parallel('before-connect')\n    this.status = App.Status.open\n    this.logger('app').debug('started')\n    this.emit('connect')\n  }\n\n  private async _listen() {\n    try {\n      const { port, host } = this.app.options\n      if (port) {\n        this._httpServer.listen(port, host)\n        this.logger('server').info('server listening at %c', `http://${host || 'localhost'}:${port}`)\n      }\n      await Promise.all(Object.values(this.adapters).map(adapter => adapter.start()))\n    } catch (error) {\n      this._close()\n      throw error\n    }\n  }\n\n  async stop() {\n    this.status = App.Status.closing\n    // `before-disconnect` event is handled by ctx.disposables\n    await Promise.all(this.state.disposables.map(dispose => dispose()))\n    this.status = App.Status.closed\n    this.logger('app').debug('stopped')\n    this.emit('disconnect')\n  }\n\n  private _close() {\n    Object.values(this.adapters).forEach(adapter => adapter.stop?.())\n    this.logger('server').debug('http server closing')\n    this._httpServer?.close()\n  }\n\n  private _resolvePrefixes(session: Session.Message) {\n    const { prefix } = this.options\n    const temp = typeof prefix === 'function' ? prefix(session) : prefix\n    return Array.isArray(temp) ? temp : [temp || '']\n  }\n\n  private async _process(session: Session.Message, next: NextFunction) {\n    let capture: RegExpMatchArray\n    let atSelf = false, appel = false, prefix: string = null\n    const pattern = /^\\[CQ:(\\w+)((,\\w+=[^,\\]]*)*)\\]/\n    let content = await session.preprocess()\n\n    // strip prefix\n    if (session.subtype !== 'private' && (capture = content.match(pattern)) && capture[1] === 'at' && capture[2].includes('id=' + session.selfId)) {\n      atSelf = appel = true\n      content = content.slice(capture[0].length).trimStart()\n      // eslint-disable-next-line no-cond-assign\n    } else if (capture = content.match(this._nameRE)) {\n      appel = true\n      content = content.slice(capture[0].length)\n    }\n\n    for (const _prefix of this._resolvePrefixes(session)) {\n      if (!content.startsWith(_prefix)) continue\n      prefix = _prefix\n      content = content.slice(_prefix.length)\n    }\n\n    // store parsed message\n    defineProperty(session, 'parsed', { content, appel, prefix })\n    this.emit(session, 'before-attach', session)\n\n    defineProperty(session, 'argv', this.bail('before-parse', content, session))\n    session.argv.root = true\n    session.argv.session = session\n\n    if (this.database) {\n      if (session.subtype === 'group') {\n        // attach group data\n        const channelFields = new Set<Channel.Field>(['flag', 'assignee'])\n        this.emit('before-attach-channel', session, channelFields)\n        const channel = await session.observeChannel(channelFields)\n\n        // emit attach event\n        if (await this.serial(session, 'attach-channel', session)) return\n\n        // ignore some group calls\n        if (channel.flag & Channel.Flag.ignore) return\n        if (channel.assignee !== session.selfId && !atSelf) return\n      }\n\n      // attach user data\n      // authority is for suggestion\n      const userFields = new Set<User.Field>(['flag', 'authority'])\n      this.emit('before-attach-user', session, userFields)\n      const user = await session.observeUser(userFields)\n\n      // emit attach event\n      if (await this.serial(session, 'attach-user', session)) return\n\n      // ignore some user calls\n      if (user.flag & User.Flag.ignore) return\n    }\n\n    // execute command\n    this.emit(session, 'attach', session)\n    if (!session.resolve(session.argv)) return next()\n    return session.execute(session.argv, next)\n  }\n\n  private _suggest(session: Session, next: NextFunction) {\n    // use `!prefix` instead of `prefix === null` to prevent from blocking other middlewares\n    // we need to make sure that the user truly has the intension to call a command\n    const { argv, quote, subtype, parsed: { content, prefix, appel } } = session\n    if (argv.command || subtype !== 'private' && !prefix && !appel) return next()\n    const target = content.split(/\\s/, 1)[0].toLowerCase()\n    if (!target) return next()\n\n    return session.suggest({\n      target,\n      next,\n      items: getCommandNames(session),\n      prefix: template('internal.command-suggestion-prefix'),\n      suffix: template('internal.command-suggestion-suffix'),\n      async apply(suggestion, next) {\n        const newMessage = suggestion + content.slice(target.length) + (quote ? ' ' + quote.content : '')\n        return this.execute(newMessage, next)\n      },\n    })\n  }\n\n  private async _handleMessage(session: Session) {\n    // preparation\n    this._sessions[session.id] = session\n    const middlewares: Middleware[] = this._hooks[Context.middleware as any]\n      .filter(([context]) => context.match(session))\n      .map(([, middleware]) => middleware)\n\n    // execute middlewares\n    let index = 0, midStack = '', lastCall = ''\n    const { prettyErrors } = this.options\n    const next = async (fallback?: NextFunction) => {\n      if (prettyErrors) {\n        lastCall = new Error().stack.split('\\n', 3)[2]\n        if (index) {\n          const capture = lastCall.match(/\\((.+)\\)/)\n          midStack = `\\n  - ${capture ? capture[1] : lastCall.slice(7)}${midStack}`\n        }\n      }\n\n      try {\n        if (!this._sessions[session.id]) {\n          throw new Error('isolated next function detected')\n        }\n        if (fallback) middlewares.push((_, next) => fallback(next))\n        return await middlewares[index++]?.(session, next)\n      } catch (error) {\n        let stack = coerce(error)\n        if (prettyErrors) {\n          const index = stack.indexOf(lastCall)\n          if (index >= 0) stack = stack.slice(0, index)\n          stack += `Middleware stack:${midStack}`\n        }\n        this.logger('session').warn(`${session.content}\\n${stack}`)\n      }\n    }\n    await next()\n\n    // update session map\n    delete this._sessions[session.id]\n    this.emit(session, 'middleware', session)\n\n    // flush user & group data\n    await session.user?._update()\n    await session.channel?._update()\n  }\n\n  private _handleArgv(content: string, session: Session) {\n    const argv = Argv.parse(content)\n    if (session.quote) {\n      argv.tokens.push({\n        content: session.quote.content,\n        quoted: true,\n        inters: [],\n        terminator: '',\n      })\n    }\n    return argv\n  }\n\n  private _handleShortcut(content: string, session: Session) {\n    const { parsed, quote } = session\n    if (parsed.prefix || quote) return\n    for (const shortcut of this._shortcuts) {\n      const { name, fuzzy, command, prefix, options = {}, args = [] } = shortcut\n      if (prefix && !parsed.appel || !command.context.match(session)) continue\n      if (typeof name === 'string') {\n        if (!fuzzy && content !== name || !content.startsWith(name)) continue\n        const message = content.slice(name.length)\n        if (fuzzy && !parsed.appel && message.match(/^\\S/)) continue\n        const argv = command.parse(message.trim(), '', [...args], { ...options })\n        argv.command = command\n        return argv\n      } else {\n        const capture = name.exec(content)\n        if (!capture) continue\n        function escape(source: any) {\n          if (typeof source !== 'string') return source\n          source = source.replace(/\\$\\$/g, '@@__PLACEHOLDER__@@')\n          capture.map((segment, index) => {\n            if (!index || index > 9) return\n            source = source.replace(new RegExp(`\\\\$${index}`, 'g'), (segment || '').replace(/\\$/g, '@@__PLACEHOLDER__@@'))\n          })\n          return source.replace(/@@__PLACEHOLDER__@@/g, '$')\n        }\n        return {\n          command,\n          args: args.map(escape),\n          options: Object.fromEntries(Object.entries(options).map(([k, v]) => [k, escape(v)])),\n        }\n      }\n    }\n  }\n}\n\nexport namespace App {\n  export enum Status { closed, opening, open, closing }\n}\n", "import { Logger, defineProperty, remove, segment, Random, Promisify, Awaitable } from 'koishi-utils'\nimport { Command } from './command'\nimport { Session } from './session'\nimport { User, Channel, Database, Assets } from './database'\nimport { Argv } from './parser'\nimport { Platform, Bot } from './adapter'\nimport { App } from './app'\nimport { inspect } from 'util'\nimport Router from '@koa/router'\n\nexport type NextFunction = (next?: NextFunction) => Promise<void>\nexport type Middleware = (session: Session, next: NextFunction) => any\nexport type Disposable = () => void\n\nexport type Plugin<T = any> = Plugin.Function<T> | Plugin.Object<T>\n\nexport namespace Plugin {\n  export type Function<T = any> = (ctx: Context, options: T) => void\n\n  export interface Meta {\n    name?: string\n    sideEffect?: boolean\n  }\n\n  export interface Object<T = any> extends Meta {\n    apply: Function<T>\n  }\n\n  export type Config<T extends Plugin> = T extends Function<infer U> ? U : T extends Object<infer U> ? U : never\n\n  export interface State<T = any> extends Meta {\n    id?: string\n    parent?: State\n    context?: Context\n    config?: T\n    plugin?: Plugin\n    children: Plugin[]\n    disposables: Disposable[]\n  }\n\n  export interface Packages {}\n\n  export type Teleporter<D extends readonly (keyof Packages)[]> = (ctx: Context, ...modules: From<D>) => void\n\n  type From<D extends readonly unknown[]> = D extends readonly [infer L, ...infer R]\n    ? [L extends keyof Packages ? Packages[L] : unknown, ...From<R>]\n    : []\n\n  export class Registry extends Map<Plugin, State> {\n    resolve(plugin: Plugin) {\n      return plugin && (typeof plugin === 'function' ? plugin : plugin.apply)\n    }\n\n    get(plugin: Plugin) {\n      return super.get(this.resolve(plugin))\n    }\n\n    set(plugin: Plugin, state: State) {\n      return super.set(this.resolve(plugin), state)\n    }\n\n    has(plugin: Plugin) {\n      return super.has(this.resolve(plugin))\n    }\n\n    delete(plugin: Plugin) {\n      return super.delete(this.resolve(plugin))\n    }\n  }\n}\n\nfunction isBailed(value: any) {\n  return value !== null && value !== false && value !== undefined\n}\n\nfunction safeRequire(id: string) {\n  try {\n    return require(id)\n  } catch {}\n}\n\ntype Filter = (session: Session) => boolean\ntype PartialSeletor<T> = (...values: T[]) => Context\n\ninterface Selector<T> extends PartialSeletor<T> {\n  except?: PartialSeletor<T>\n}\n\nexport interface Context extends Context.Delegates {}\n\nexport class Context {\n  static readonly middleware = Symbol('middleware')\n  static readonly current = Symbol('source')\n\n  protected _bots: Bot[] & Record<string, Bot>\n\n  protected constructor(public filter: Filter, public app?: App, private _plugin: Plugin = null) {}\n\n  private static inspect(plugin: Plugin) {\n    return !plugin ? 'root' : typeof plugin === 'object' && plugin.name || 'anonymous'\n  }\n\n  [inspect.custom]() {\n    return `Context <${Context.inspect(this._plugin)}>`\n  }\n\n  private createSelector<K extends keyof Session>(key: K) {\n    const selector: Selector<Session[K]> = (...args) => this.select(key, ...args)\n    selector.except = (...args) => this.unselect(key, ...args)\n    return selector\n  }\n\n  get user() {\n    return this.createSelector('userId')\n  }\n\n  get self() {\n    return this.createSelector('selfId')\n  }\n\n  get group() {\n    return this.createSelector('groupId')\n  }\n\n  get channel() {\n    return this.createSelector('channelId')\n  }\n\n  get platform() {\n    return this.createSelector('platform')\n  }\n\n  get private() {\n    return this.unselect('groupId').user\n  }\n\n  get bots() {\n    return this.app._bots\n  }\n\n  logger(name: string) {\n    return new Logger(name)\n  }\n\n  select<K extends keyof Session>(key: K, ...values: Session[K][]) {\n    return this.intersect((session) => {\n      return values.length ? values.includes(session[key]) : !!session[key]\n    })\n  }\n\n  unselect<K extends keyof Session>(key: K, ...values: Session[K][]) {\n    return this.intersect((session) => {\n      return values.length ? !values.includes(session[key]) : !session[key]\n    })\n  }\n\n  all() {\n    return new Context(() => true, this.app, this._plugin)\n  }\n\n  union(arg: Filter | Context) {\n    const filter = typeof arg === 'function' ? arg : arg.filter\n    return new Context(s => this.filter(s) || filter(s), this.app, this._plugin)\n  }\n\n  intersect(arg: Filter | Context) {\n    const filter = typeof arg === 'function' ? arg : arg.filter\n    return new Context(s => this.filter(s) && filter(s), this.app, this._plugin)\n  }\n\n  except(arg: Filter | Context) {\n    const filter = typeof arg === 'function' ? arg : arg.filter\n    return new Context(s => this.filter(s) && !filter(s), this.app, this._plugin)\n  }\n\n  match(session?: Session) {\n    return !session || this.filter(session)\n  }\n\n  get state() {\n    return this.app.registry.get(this._plugin)\n  }\n\n  addSideEffect(state = this.state) {\n    while (state && !state.sideEffect) {\n      state.sideEffect = true\n      state = state.parent\n    }\n  }\n\n  private teleport(modules: any[], callback: Plugin.Teleporter<any>) {\n    const states: Plugin.State[] = []\n    for (const module of modules) {\n      const state = this.app.registry.get(module)\n      if (!state) return\n      states.push(state)\n    }\n    const plugin = (ctx: Context) => callback(ctx, ...modules as [])\n    const dispose = () => this.dispose(plugin)\n    this.plugin(plugin)\n    states.every(state => state.disposables.push(dispose))\n    this.before('disconnect', () => {\n      states.every(state => remove(state.disposables, dispose))\n    })\n  }\n\n  with<D extends readonly (keyof Plugin.Packages)[]>(deps: D, callback: Plugin.Teleporter<D>) {\n    const modules = deps.map(safeRequire)\n    if (!modules.every(val => val)) return this\n    this.teleport(modules, callback)\n    this.on('plugin-added', (added) => {\n      const modules = deps.map(safeRequire)\n      if (modules.includes(added)) this.teleport(modules, callback)\n    })\n    return this\n  }\n\n  plugin<T extends Plugin>(plugin: T, options?: boolean | Plugin.Config<T>): this\n  plugin(plugin: Plugin, options?: any) {\n    if (options === false) return this\n    if (options === true) options = undefined\n\n    if (this.app.registry.has(plugin)) {\n      this.logger('app').warn(new Error(`duplicate plugin <${Context.inspect(plugin)}> detected`))\n      return this\n    }\n\n    const ctx: this = Object.create(this)\n    defineProperty(ctx, '_plugin', plugin)\n    this.app.registry.set(plugin, {\n      plugin,\n      id: Random.uuid(),\n      context: this,\n      config: options,\n      parent: this.state,\n      children: [],\n      disposables: [],\n    })\n\n    if (typeof plugin === 'function') {\n      plugin(ctx, options)\n    } else if (plugin && typeof plugin === 'object' && typeof plugin.apply === 'function') {\n      ctx.state.name = plugin.name\n      if (plugin.sideEffect) ctx.addSideEffect()\n      plugin.apply(ctx, options)\n    } else {\n      this.app.registry.delete(plugin)\n      throw new Error('invalid plugin, expect function or object with an \"apply\" method')\n    }\n\n    this.state.children.push(plugin)\n    this.emit('plugin-added', plugin, this.app.registry)\n    return this\n  }\n\n  async dispose(plugin = this._plugin) {\n    const state = this.app.registry.get(plugin)\n    if (!state) return\n    if (state.sideEffect) throw new Error('plugins with side effect cannot be disposed')\n    await Promise.allSettled([\n      ...state.children.slice().map(plugin => this.dispose(plugin)),\n      ...state.disposables.map(dispose => dispose()),\n    ]).finally(() => {\n      this.app.registry.delete(plugin)\n      remove(state.parent.children, plugin)\n      this.emit('plugin-removed', plugin, this.app.registry)\n    })\n  }\n\n  async parallel<K extends EventName>(name: K, ...args: Parameters<EventMap[K]>): Promise<void>\n  async parallel<K extends EventName>(session: Session, name: K, ...args: Parameters<EventMap[K]>): Promise<void>\n  async parallel(...args: any[]) {\n    const tasks: Promise<any>[] = []\n    const session = typeof args[0] === 'object' ? args.shift() : null\n    const name = args.shift()\n    for (const [context, callback] of this.app._hooks[name] || []) {\n      if (!context.match(session)) continue\n      tasks.push(callback.apply(session, args))\n    }\n    await Promise.all(tasks)\n  }\n\n  emit<K extends EventName>(name: K, ...args: Parameters<EventMap[K]>): void\n  emit<K extends EventName>(session: Session, name: K, ...args: Parameters<EventMap[K]>): void\n  emit(...args: [any, ...any[]]) {\n    this.parallel(...args)\n  }\n\n  waterfall<K extends EventName>(name: K, ...args: Parameters<EventMap[K]>): Promisify<ReturnType<EventMap[K]>>\n  waterfall<K extends EventName>(session: Session, name: K, ...args: Parameters<EventMap[K]>): Promisify<ReturnType<EventMap[K]>>\n  async waterfall(...args: [any, ...any[]]) {\n    const session = typeof args[0] === 'object' ? args.shift() : null\n    const name = args.shift()\n    for (const [context, callback] of this.app._hooks[name] || []) {\n      if (!context.match(session)) continue\n      const result = await callback.apply(session, args)\n      args[0] = result\n    }\n    return args[0]\n  }\n\n  chain<K extends EventName>(name: K, ...args: Parameters<EventMap[K]>): ReturnType<EventMap[K]>\n  chain<K extends EventName>(session: Session, name: K, ...args: Parameters<EventMap[K]>): ReturnType<EventMap[K]>\n  chain(...args: [any, ...any[]]) {\n    const session = typeof args[0] === 'object' ? args.shift() : null\n    const name = args.shift()\n    for (const [context, callback] of this.app._hooks[name] || []) {\n      if (!context.match(session)) continue\n      const result = callback.apply(session, args)\n      args[0] = result\n    }\n    return args[0]\n  }\n\n  serial<K extends EventName>(name: K, ...args: Parameters<EventMap[K]>): Promisify<ReturnType<EventMap[K]>>\n  serial<K extends EventName>(session: Session, name: K, ...args: Parameters<EventMap[K]>): Promisify<ReturnType<EventMap[K]>>\n  async serial(...args: any[]) {\n    const session = typeof args[0] === 'object' ? args.shift() : null\n    const name = args.shift()\n    for (const [context, callback] of this.app._hooks[name] || []) {\n      if (!context.match(session)) continue\n      const result = await callback.apply(session, args)\n      if (isBailed(result)) return result\n    }\n  }\n\n  bail<K extends EventName>(name: K, ...args: Parameters<EventMap[K]>): ReturnType<EventMap[K]>\n  bail<K extends EventName>(session: Session, name: K, ...args: Parameters<EventMap[K]>): ReturnType<EventMap[K]>\n  bail(...args: any[]) {\n    const session = typeof args[0] === 'object' ? args.shift() : null\n    const name = args.shift()\n    for (const [context, callback] of this.app._hooks[name] || []) {\n      if (!context.match(session)) continue\n      const result = callback.apply(session, args)\n      if (isBailed(result)) return result\n    }\n  }\n\n  on<K extends EventName>(name: K, listener: EventMap[K], prepend?: boolean): () => boolean\n  on(name: string & EventName, listener: Disposable, prepend = false) {\n    const method = prepend ? 'unshift' : 'push'\n\n    // handle special events\n    if (name === 'connect' && this.app.status === App.Status.open) {\n      return listener(), () => false\n    } else if (name === 'before-disconnect') {\n      this.state.disposables[method](listener)\n      return () => remove(this.state.disposables, listener)\n    } else if (name === 'before-connect') {\n      // before-connect is side effect\n      this.addSideEffect()\n    } else if (typeof name === 'string' && name.startsWith('delegate/')) {\n      if (this[name.slice(9)]) return listener(), () => false\n    }\n\n    const hooks = this.app._hooks[name] ||= []\n    if (hooks.length >= this.app.options.maxListeners) {\n      this.logger('app').warn(\n        'max listener count (%d) for event \"%s\" exceeded, which may be caused by a memory leak',\n        this.app.options.maxListeners, name,\n      )\n    }\n\n    hooks[method]([this, listener])\n    const dispose = () => this.off(name, listener)\n    this.state.disposables.push(dispose)\n    return dispose\n  }\n\n  before<K extends BeforeEventName>(name: K, listener: BeforeEventMap[K], append = false) {\n    const seg = name.split('/')\n    seg[seg.length - 1] = 'before-' + seg[seg.length - 1]\n    return this.on(seg.join('/') as EventName, listener, !append)\n  }\n\n  once<K extends EventName>(name: K, listener: EventMap[K], prepend = false) {\n    const dispose = this.on(name, function (...args: any[]) {\n      dispose()\n      return listener.apply(this, args)\n    }, prepend)\n    return dispose\n  }\n\n  off<K extends EventName>(name: K, listener: EventMap[K]) {\n    const index = (this.app._hooks[name] || [])\n      .findIndex(([context, callback]) => context === this && callback === listener)\n    if (index >= 0) {\n      this.app._hooks[name].splice(index, 1)\n      return true\n    }\n  }\n\n  middleware(middleware: Middleware, prepend = false) {\n    return this.on(Context.middleware, middleware, prepend)\n  }\n\n  private createTimerDispose(timer: NodeJS.Timeout) {\n    const dispose = () => {\n      clearTimeout(timer)\n      return remove(this.state.disposables, dispose)\n    }\n    this.state.disposables.push(dispose)\n    return dispose\n  }\n\n  setTimeout(callback: (...args: any[]) => void, ms: number, ...args: any[]) {\n    const dispose = this.createTimerDispose(setTimeout(() => {\n      dispose()\n      callback()\n    }, ms, ...args))\n    return dispose\n  }\n\n  setInterval(callback: (...args: any[]) => void, ms: number, ...args: any[]) {\n    return this.createTimerDispose(setInterval(callback, ms, ...args))\n  }\n\n  command<D extends string>(def: D, config?: Command.Config): Command<never, never, Argv.ArgumentType<D>>\n  command<D extends string>(def: D, desc: string, config?: Command.Config): Command<never, never, Argv.ArgumentType<D>>\n  command(def: string, ...args: [Command.Config?] | [string, Command.Config?]) {\n    const desc = typeof args[0] === 'string' ? args.shift() as string : ''\n    const config = args[0] as Command.Config\n    const path = def.split(' ', 1)[0].toLowerCase()\n    const decl = def.slice(path.length)\n    const segments = path.split(/(?=[./])/g)\n\n    let parent: Command, root: Command\n    segments.forEach((segment, index) => {\n      const code = segment.charCodeAt(0)\n      const name = code === 46 ? parent.name + segment : code === 47 ? segment.slice(1) : segment\n      let command = this.app._commands.get(name)\n      if (command) {\n        if (parent) {\n          if (command === parent) {\n            throw new Error(`cannot set a command (${command.name}) as its own subcommand`)\n          }\n          if (command.parent) {\n            if (command.parent !== parent) {\n              throw new Error(`cannot create subcommand ${path}: ${command.parent.name}/${command.name} already exists`)\n            }\n          } else {\n            command.parent = parent\n            parent.children.push(command)\n          }\n        }\n        return parent = command\n      }\n      command = new Command(name, decl, index === segments.length - 1 ? desc : '', this)\n      if (!root) root = command\n      if (parent) {\n        command.parent = parent\n        command.config.authority = parent.config.authority\n        parent.children.push(command)\n      }\n      parent = command\n    })\n\n    if (desc) parent.description = desc\n    Object.assign(parent.config, config)\n    if (!config?.patch) {\n      if (root) this.state.disposables.unshift(() => root.dispose())\n      return parent\n    }\n\n    if (root) root.dispose()\n    const command = Object.create(parent)\n    command._disposables = this.state.disposables\n    return command\n  }\n\n  async transformAssets(content: string, assets = this.assets) {\n    if (!assets) return content\n    return segment.transformAsync(content, Object.fromEntries(assets.types.map((type) => {\n      return [type, async (data) => segment(type, { url: await assets.upload(data.url, data.file) })]\n    })))\n  }\n\n  getBot(platform: Platform, selfId?: string) {\n    if (selfId) return this.bots[`${platform}:${selfId}`]\n    return this.bots.find(bot => bot.platform === platform)\n  }\n\n  getSelfIds(type?: Platform, assignees?: readonly string[]): Record<string, readonly string[]> {\n    if (type) {\n      assignees ||= this.app.bots.filter(bot => bot.platform === type).map(bot => bot.selfId)\n      return { [type]: assignees }\n    }\n    const platforms: Record<string, string[]> = {}\n    for (const bot of this.app.bots) {\n      (platforms[bot.platform] ||= []).push(bot.selfId)\n    }\n    return platforms\n  }\n\n  async broadcast(content: string, forced?: boolean): Promise<string[]>\n  async broadcast(channels: readonly string[], content: string, forced?: boolean): Promise<string[]>\n  async broadcast(...args: [string, boolean?] | [readonly string[], string, boolean?]) {\n    let channels: string[]\n    if (Array.isArray(args[0])) channels = args.shift() as any\n    const [content, forced] = args as [string, boolean]\n    if (!content) return []\n\n    const data = this.database\n      ? await this.database.getAssignedChannels(['id', 'assignee', 'flag'])\n      : channels.map((id) => {\n        const [type] = id.split(':')\n        const bot = this.getBot(type as never)\n        return bot && { id, assignee: bot.selfId, flag: 0 }\n      }).filter(Boolean)\n\n    const assignMap: Record<string, Record<string, string[]>> = {}\n    for (const { id, assignee, flag } of data) {\n      if (channels && !channels.includes(id)) continue\n      if (!forced && (flag & Channel.Flag.silent)) continue\n      const [type] = id.split(':')\n      const cid = id.slice(type.length + 1)\n      const map = assignMap[type] ||= {}\n      if (map[assignee]) {\n        map[assignee].push(cid)\n      } else {\n        map[assignee] = [cid]\n      }\n    }\n\n    return (await Promise.all(Object.entries(assignMap).flatMap(([type, map]) => {\n      return this.app.bots.map((bot) => {\n        if (bot.platform !== type) return Promise.resolve([])\n        return bot.broadcast(map[bot.selfId] || [], content)\n      })\n    }))).flat(1)\n  }\n\n  static delegate(key: string & keyof Context) {\n    if (Object.prototype.hasOwnProperty.call(Context.prototype, key)) return\n    const privateKey = Symbol(key)\n    Object.defineProperty(Context.prototype, key, {\n      get() {\n        if (!this.app[privateKey]) return\n        const value = Object.create(this.app[privateKey])\n        defineProperty(value, Context.current, this)\n        return value\n      },\n      set(value) {\n        if (!this.app[privateKey]) this.emit('delegate/' + key)\n        defineProperty(this.app, privateKey, value)\n      },\n    })\n  }\n}\n\nContext.delegate('database')\nContext.delegate('assets')\nContext.delegate('router')\n\nexport namespace Context {\n  export interface Delegates {\n    database: Database\n    assets: Assets\n    router: Router\n  }\n}\n\ntype FlattenEvents<T> = {\n  [K in keyof T & string]: K | `${K}/${FlattenEvents<T[K]>}`\n}[keyof T & string]\n\ntype SessionEventMap = {\n  [K in FlattenEvents<Session.Events>]: K extends `${infer X}/${infer R}`\n    ? R extends `${infer Y}/${any}`\n      ? (session: Session.Payload<X, Y>) => void\n      : (session: Session.Payload<X, R>) => void\n    : (session: Session.Payload<K>) => void\n}\n\ntype DelegateEventMap = {\n  [K in keyof Context.Delegates as `delegate/${K}`]: () => void\n}\n\ntype EventName = keyof EventMap\ntype OmitSubstring<S extends string, T extends string> = S extends `${infer L}${T}${infer R}` ? `${L}${R}` : never\ntype BeforeEventName = OmitSubstring<EventName & string, 'before-'>\n\nexport type BeforeEventMap = { [E in EventName & string as OmitSubstring<E, 'before-'>]: EventMap[E] }\n\nexport interface EventMap extends SessionEventMap, DelegateEventMap {\n  [Context.middleware]: Middleware\n\n  // Koishi events\n  'appellation'(name: string, session: Session): string\n  'before-parse'(content: string, session: Session): Argv\n  'parse'(argv: Argv, session: Session): string\n  'before-attach-channel'(session: Session, fields: Set<Channel.Field>): void\n  'attach-channel'(session: Session): Awaitable<void | boolean>\n  'before-attach-user'(session: Session, fields: Set<User.Field>): void\n  'attach-user'(session: Session): Awaitable<void | boolean>\n  'before-attach'(session: Session): void\n  'attach'(session: Session): void\n  'before-send'(session: Session<never, never, Platform, 'send'>): Awaitable<void | boolean>\n  'before-command'(argv: Argv): Awaitable<void | string>\n  'command'(argv: Argv): Awaitable<void>\n  'command-added'(command: Command): void\n  'command-removed'(command: Command): void\n  'middleware'(session: Session): void\n  'plugin-added'(plugin: Plugin, registry: Map<Plugin, Plugin.State>): void\n  'plugin-removed'(plugin: Plugin, registry: Map<Plugin, Plugin.State>): void\n  'before-connect'(): Awaitable<void>\n  'connect'(): void\n  'before-disconnect'(): Awaitable<void>\n  'disconnect'(): void\n}\n\n// hack into router methods to make sure\n// that koa middlewares are disposable\nconst register = Router.prototype.register\nRouter.prototype.register = function (this: Router, ...args) {\n  const layer = register.apply(this, args)\n  const context: Context = this[Context.current]\n  context?.state.disposables.push(() => {\n    remove(this.stack, layer)\n  })\n  return layer\n}\n", "import { Command, getUsage, getUsageName, ValidationField } from './command'\nimport { TableType } from './database'\nimport { Session, FieldCollector } from './session'\nimport { template } from 'koishi-utils'\nimport { Context } from './context'\nimport { Argv } from './parser'\n\ninterface HelpOptions {\n  showHidden?: boolean\n  authority?: boolean\n}\n\nexport interface HelpConfig extends Command.Config {\n  shortcut?: boolean\n  options?: boolean\n}\n\nexport default function apply(ctx: Context, config: HelpConfig = {}) {\n  if (config.options !== false) {\n    ctx.on('command-added', (cmd) => {\n      cmd.option('help', '-h  显示此信息', { hidden: true })\n    })\n\n    // show help when use `-h, --help` or when there is no action\n    ctx.before('command', async ({ command, session, options }) => {\n      if (command['_actions'].length && !options['help']) return\n      await session.execute({\n        name: 'help',\n        args: [command.name],\n      })\n      return ''\n    })\n  }\n\n  const app = ctx.app\n  function findCommand(target: string) {\n    const command = app._commands.resolve(target)\n    if (command) return command\n    const shortcut = app._shortcuts.find(({ name }) => {\n      return typeof name === 'string' ? name === target : name.test(target)\n    })\n    if (shortcut) return shortcut.command\n  }\n\n  const createCollector = <T extends TableType>(key: T): FieldCollector<T> => (argv, fields) => {\n    const { args: [target], session } = argv\n    const command = findCommand(target)\n    if (!command) return\n    session.collect(key, { ...argv, command, args: [], options: { help: true } }, fields)\n  }\n\n  const cmd = ctx.command('help [command]', '显示帮助信息', { authority: 0, ...config })\n    .userFields(['authority'])\n    .userFields(createCollector('user'))\n    .channelFields(createCollector('channel'))\n    .option('authority', '-a  显示权限设置')\n    .option('showHidden', '-H  查看隐藏的选项和指令')\n    .action(async ({ session, options }, target) => {\n      if (!target) {\n        const commands = app._commandList.filter(cmd => cmd.parent === null)\n        const output = formatCommands('internal.global-help-prolog', session, commands, options)\n        const epilog = template('internal.global-help-epilog')\n        if (epilog) output.push(epilog)\n        return output.filter(Boolean).join('\\n')\n      }\n\n      const command = findCommand(target)\n      if (!command?.context.match(session)) {\n        session.suggest({\n          target,\n          items: getCommandNames(session),\n          prefix: template('internal.help-suggestion-prefix'),\n          suffix: template('internal.help-suggestion-suffix'),\n          async apply(suggestion) {\n            await this.observeUser(['authority', 'usage', 'timers'])\n            const output = await showHelp(app._commands.get(suggestion), this as any, options)\n            return session.send(output)\n          },\n        })\n        return\n      }\n\n      return showHelp(command, session, options)\n    })\n\n  if (config.shortcut !== false) cmd.shortcut('帮助', { fuzzy: true })\n}\n\nexport function getCommandNames(session: Session) {\n  return session.app._commandList\n    .filter(cmd => cmd.match(session) && !cmd.config.hidden)\n    .flatMap(cmd => cmd._aliases)\n}\n\nfunction* getCommands(session: Session<'authority'>, commands: Command[], showHidden = false): Generator<Command> {\n  for (const command of commands) {\n    if (!showHidden && command.config.hidden) continue\n    if (command.match(session)) {\n      yield command\n    } else {\n      yield* getCommands(session, command.children, showHidden)\n    }\n  }\n}\n\nfunction formatCommands(path: string, session: Session<ValidationField>, children: Command[], options: HelpOptions) {\n  const commands = Array\n    .from(getCommands(session, children, options.showHidden))\n    .sort((a, b) => a.name > b.name ? 1 : -1)\n  if (!commands.length) return []\n\n  let hasSubcommand = false\n  const output = commands.map(({ name, config, children, description }) => {\n    let output = '    ' + name\n    if (options.authority) {\n      output += ` (${config.authority}${children.length ? (hasSubcommand = true, '*') : ''})`\n    }\n    output += '  ' + description\n    return output\n  })\n  const hints: string[] = []\n  if (options.authority) hints.push(template('internal.hint-authority'))\n  if (hasSubcommand) hints.push(template('internal.hint-subcommand'))\n  output.unshift(template(path, [template.brace(hints)]))\n  return output\n}\n\nfunction getOptionVisibility(option: Argv.OptionDeclaration, session: Session<ValidationField>) {\n  if (session.user && option.authority > session.user.authority) return false\n  return !session.resolveValue(option.hidden)\n}\n\nfunction getOptions(command: Command, session: Session<ValidationField>, maxUsage: number, config: HelpOptions) {\n  if (command.config.hideOptions && !config.showHidden) return []\n  const options = config.showHidden\n    ? Object.values(command._options)\n    : Object.values(command._options).filter(option => getOptionVisibility(option, session))\n  if (!options.length) return []\n\n  const output = config.authority && options.some(o => o.authority)\n    ? [template('internal.available-options-with-authority')]\n    : [template('internal.available-options')]\n\n  options.forEach((option) => {\n    const authority = option.authority && config.authority ? `(${option.authority}) ` : ''\n    let line = `    ${authority}${option.description}`\n    if (option.notUsage && maxUsage !== Infinity) {\n      line += template('internal.option-not-usage')\n    }\n    output.push(line)\n  })\n\n  return output\n}\n\nasync function showHelp(command: Command, session: Session<ValidationField>, config: HelpOptions) {\n  const output = [command.name + command.declaration]\n\n  if (command.description) output.push(command.description)\n\n  if (command.context.database) {\n    await session.observeUser(['authority', 'timers', 'usage'])\n  }\n\n  if (command._aliases.length > 1) {\n    output.push(template('internal.command-aliases', Array.from(command._aliases.slice(1)).join('，')))\n  }\n\n  const maxUsage = command.getConfig('maxUsage', session)\n  if (session.user) {\n    const name = getUsageName(command)\n    const minInterval = command.getConfig('minInterval', session)\n    const count = getUsage(name, session.user)\n\n    if (maxUsage < Infinity) {\n      output.push(template('internal.command-max-usage', Math.min(count, maxUsage), maxUsage))\n    }\n\n    const due = session.user.timers[name]\n    if (minInterval > 0) {\n      const nextUsage = due ? (Math.max(0, due - Date.now()) / 1000).toFixed() : 0\n      output.push(template('internal.command-min-interval', nextUsage, minInterval / 1000))\n    }\n\n    if (command.config.authority > 1) {\n      output.push(template('internal.command-authority', command.config.authority))\n    }\n  }\n\n  const usage = command._usage\n  if (usage) {\n    output.push(typeof usage === 'string' ? usage : await usage.call(command, session))\n  }\n\n  output.push(...getOptions(command, session, maxUsage, config))\n\n  if (command._examples.length) {\n    output.push(template('internal.command-examples'), ...command._examples.map(example => '    ' + example))\n  }\n\n  output.push(...formatCommands('internal.subcommand-prolog', session, command.children, config))\n\n  return output.filter(Boolean).join('\\n')\n}\n\n/* eslint-disable quote-props */\ntemplate.set('internal', {\n  // command\n  'low-authority': '权限不足。',\n  'usage-exhausted': '调用次数已达上限。',\n  'too-frequent': '调用过于频繁，请稍后再试。',\n  'insufficient-arguments': '缺少参数，输入帮助以查看用法。',\n  'redunant-arguments': '存在多余参数，输入帮助以查看用法。',\n  'invalid-argument': '参数 {0} 输入无效，{1}',\n  'unknown-option': '存在未知选项 {0}，输入帮助以查看用法。',\n  'invalid-option': '选项 {0} 输入无效，{1}',\n  'check-syntax': '输入帮助以查看用法。',\n\n  // parser\n  'invalid-number': '请提供一个数字。',\n  'invalid-integer': '请提供一个整数。',\n  'invalid-posint': '请提供一个正整数。',\n  'invalid-natural': '请提供一个非负整数。',\n  'invalid-date': '请输入合法的时间。',\n  'invalid-user': '请指定正确的用户。',\n  'invalid-channel': '请指定正确的频道。',\n\n  // suggest\n  'suggestion': '您要找的是不是{0}？',\n  'command-suggestion-prefix': '',\n  'command-suggestion-suffix': '发送空行或句号以使用推测的指令。',\n\n  // help\n  'help-suggestion-prefix': '指令未找到。',\n  'help-suggestion-suffix': '发送空行或句号以使用推测的指令。',\n  'subcommand-prolog': '可用的子指令有{0}：',\n  'global-help-prolog': '当前可用的指令有{0}：',\n  'global-help-epilog': '输入“帮助 指令名”查看特定指令的语法和使用示例。',\n  'available-options': '可用的选项有：',\n  'available-options-with-authority': '可用的选项有（括号内为额外要求的权限等级）：',\n  'option-not-usage': '（不计入总次数）',\n  'hint-authority': '括号内为对应的最低权限等级',\n  'hint-subcommand': '标有星号的表示含有子指令',\n  'command-aliases': '别名：{0}。',\n  'command-examples': '使用示例：',\n  'command-authority': '最低权限：{0} 级。',\n  'command-max-usage': '已调用次数：{0}/{1}。',\n  'command-min-interval': '距离下次调用还需：{0}/{1} 秒。',\n})\n"],
  "mappings": "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",
  "names": []
}

var __create = Object.create;
var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __markAsModule = (target) => __defProp(target, "__esModule", { value: true });
var __export = (target, all) => {
  __markAsModule(target);
  for (var name2 in all)
    __defProp(target, name2, { get: all[name2], enumerable: true });
};
var __reExport = (target, module2, desc) => {
  if (module2 && typeof module2 === "object" || typeof module2 === "function") {
    for (let key of __getOwnPropNames(module2))
      if (!__hasOwnProp.call(target, key) && key !== "default")
        __defProp(target, key, { get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable });
  }
  return target;
};
var __toModule = (module2) => {
  return __reExport(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, "default", module2 && module2.__esModule && "default" in module2 ? { get: () => module2.default, enumerable: true } : { value: module2, enumerable: true })), module2);
};

// packages/plugin-common/src/index.ts
__export(exports, {
  admin: () => admin,
  apply: () => apply4,
  bind: () => bind,
  broadcast: () => broadcast,
  callme: () => callme,
  contextify: () => contextify,
  echo: () => echo,
  feedback: () => feedback,
  name: () => name,
  recall: () => recall,
  relay: () => relay,
  repeater: () => repeater,
  respondent: () => respondent,
  verifier: () => verifier
});

// packages/plugin-common/src/basic.ts
var import_koishi_core = __toModule(require("koishi-core"));
var import_koishi_utils = __toModule(require("koishi-utils"));
import_koishi_utils.template.set("common", {
  "expect-text": "请输入要发送的文本。",
  "expect-command": "请输入要触发的指令。",
  "expect-context": "请提供新的上下文。",
  "invalid-private-member": "无法在私聊上下文使用 --member 选项。",
  "feedback-receive": "收到来自 {0} 的反馈信息：\n{1}",
  "feedback-success": "反馈信息发送成功！",
  "relay": "{0}: {1}"
});
function broadcast(ctx) {
  ctx.select("database").command("common/broadcast <message:text>", "全服广播", { authority: 4 }).option("forced", "-f  无视 silent 标签进行广播").option("only", "-o  仅向当前账号负责的群进行广播").action(async ({ options, session }, message) => {
    if (!message)
      return (0, import_koishi_utils.template)("common.expect-text");
    if (!options.only) {
      await ctx.broadcast(message, options.forced);
      return;
    }
    const fields = ["id"];
    if (!options.forced)
      fields.push("flag");
    let groups = await ctx.database.getAssignedChannels(fields, { [session.platform]: [session.selfId] });
    if (!options.forced) {
      groups = groups.filter((g) => !(g.flag & import_koishi_core.Channel.Flag.silent));
    }
    await session.bot.broadcast(groups.map((g) => g.id.slice(session.platform["length"] + 1)), message);
  });
}
function contextify(ctx) {
  ctx.select("database").command("common/contextify <command:text>", "在特定上下文中触发指令", { authority: 3 }).alias("ctxf").userFields(["authority"]).option("user", "-u [id:user]  使用用户私聊上下文").option("member", "-m [id:user]  使用当前频道成员上下文").option("channel", "-c [id:channel]  使用群聊上下文").action(async ({ session, options }, message) => {
    var _a, _b, _c, _d;
    if (!message)
      return (0, import_koishi_utils.template)("common.expect-command");
    if (options.member) {
      if (session.subtype === "private") {
        return (0, import_koishi_utils.template)("common.invalid-private-member");
      }
      options.channel = session.cid;
      options.user = options.member;
    }
    if (!options.user && !options.channel) {
      return (0, import_koishi_utils.template)("common.expect-context");
    }
    const sess = new import_koishi_core.Session(ctx.app, session);
    sess.send = session.send.bind(session);
    sess.sendQueued = session.sendQueued.bind(session);
    if (!options.channel) {
      sess.subtype = "private";
    } else if (options.channel !== session.cid) {
      sess.channelId = import_koishi_core.Argv.parsePid(options.channel)[1];
      sess.cid = `${sess.platform}:${sess.channelId}`;
      sess.subtype = "group";
      await sess.observeChannel();
    } else {
      sess.channel = session.channel;
    }
    if (options.user && options.user !== session.uid) {
      sess.userId = sess.author.userId = import_koishi_core.Argv.parsePid(options.user)[1];
      sess.uid = `${sess.platform}:${sess.userId}`;
      const user = await sess.observeUser(["authority"]);
      if (session.user.authority <= user.authority) {
        return (0, import_koishi_utils.template)("internal.low-authority");
      }
    } else {
      sess.user = session.user;
    }
    if (options.member) {
      const info = await ((_b = (_a = session.bot).getGroupMember) == null ? void 0 : _b.call(_a, sess.groupId, sess.userId).catch(() => ({})));
      Object.assign(sess.author, info);
    } else if (options.user) {
      const info = await ((_d = (_c = session.bot).getUser) == null ? void 0 : _d.call(_c, sess.userId).catch(() => ({})));
      Object.assign(sess.author, info);
    }
    await sess.execute(message);
  });
}
function echo(ctx) {
  ctx.command("common/echo <message:text>", "向当前上下文发送消息", { authority: 2 }).option("anonymous", "-a  匿名发送消息", { authority: 3 }).option("forceAnonymous", "-A  匿名发送消息", { authority: 3 }).option("escape", "-e  发送转义消息", { authority: 3 }).option("user", "-u [user:user]  发送到用户", { authority: 3 }).option("channel", "-c [channel:channel]  发送到频道", { authority: 3 }).action(async ({ options }, message) => {
    if (!message)
      return (0, import_koishi_utils.template)("common.expect-text");
    if (options.escape) {
      message = import_koishi_utils.segment.unescape(message);
    }
    if (options.forceAnonymous) {
      message = (0, import_koishi_utils.segment)("anonymous") + message;
    } else if (options.anonymous) {
      message = (0, import_koishi_utils.segment)("anonymous", { ignore: true }) + message;
    }
    const target = options.user || options.channel;
    if (target) {
      const [platform] = target.split(":");
      const id = target.slice(platform.length + 1);
      const bot = ctx.getBot(platform);
      if (options.user) {
        await bot.sendPrivateMessage(id, message);
      } else {
        await bot.sendMessage(id, message, "unknown");
      }
      return;
    }
    return message;
  });
}
function feedback(ctx, operators) {
  const feedbacks = {};
  ctx.command("common/feedback <message:text>", "发送反馈信息给作者").userFields(["name", "id"]).action(async ({ session }, text) => {
    if (!text)
      return (0, import_koishi_utils.template)("common.expect-text");
    const { username: name2, userId } = session;
    const nickname = name2 === "" + userId ? userId : `${name2} (${userId})`;
    const message = (0, import_koishi_utils.template)("common.feedback-receive", nickname, text);
    const delay = ctx.app.options.delay.broadcast;
    const data = [session.sid, session.channelId, session.groupId];
    for (let index = 0; index < operators.length; ++index) {
      if (index && delay)
        await (0, import_koishi_utils.sleep)(delay);
      const [platform, userId2] = import_koishi_core.Argv.parsePid(operators[index]);
      const id = await ctx.getBot(platform).sendPrivateMessage(userId2, message);
      feedbacks[id] = data;
    }
    return (0, import_koishi_utils.template)("common.feedback-success");
  });
  ctx.middleware((session, next) => {
    const { quote, parsed } = session;
    if (!parsed.content || !quote)
      return next();
    const data = feedbacks[quote.messageId];
    if (!data)
      return next();
    return ctx.bots[data[0]].sendMessage(data[1], parsed.content, data[2]);
  });
}
function recall(ctx, { recall: recall2 = 10 }) {
  ctx = ctx.group();
  const recent = {};
  ctx.on("send", (session) => {
    var _a;
    const list = recent[_a = session.channelId] || (recent[_a] = []);
    list.unshift(session.messageId);
    if (list.length > recall2) {
      list.pop();
    }
  });
  ctx.command("common/recall [count:number]", "撤回 bot 发送的消息", { authority: 2 }).action(async ({ session }, count = 1) => {
    const list = recent[session.channelId];
    if (!list)
      return "近期没有发送消息。";
    const removal = list.splice(0, count);
    const delay = ctx.app.options.delay.broadcast;
    if (!list.length)
      delete recent[session.channelId];
    for (let index = 0; index < removal.length; index++) {
      if (index && delay)
        await (0, import_koishi_utils.sleep)(delay);
      try {
        await session.bot.deleteMessage(session.channelId, removal[index]);
      } catch (error) {
        ctx.logger("bot").warn(error);
      }
    }
  });
}
function relay(ctx, relays) {
  const relayMap = {};
  async function sendRelay(session, { destination, selfId, lifespan = import_koishi_utils.Time.hour }) {
    const [platform, channelId] = import_koishi_core.Argv.parsePid(destination);
    const bot = ctx.getBot(platform, selfId);
    if (!session.parsed.content)
      return;
    const content = (0, import_koishi_utils.template)("common.relay", session.username, session.parsed.content);
    const id = await bot.sendMessage(channelId, content, "unknown");
    relayMap[id] = { source: destination, destination: session.cid, selfId: session.selfId, lifespan };
    setTimeout(() => delete relayMap[id], lifespan);
  }
  ctx.middleware((session, next) => {
    const { quote = {} } = session;
    const data = relayMap[quote.messageId];
    if (data)
      return sendRelay(session, data);
    const tasks = [];
    for (const options of relays) {
      if (session.cid !== options.source)
        continue;
      tasks.push(sendRelay(session, options).catch());
    }
    tasks.push(next());
    return Promise.all(tasks);
  });
}
function respondent(ctx, respondents) {
  ctx.middleware((session, next) => {
    const message = (0, import_koishi_utils.simplify)(session.content);
    for (const { match, reply } of respondents) {
      const capture = typeof match === "string" ? message === match && [message] : message.match(match);
      if (capture)
        return session.send(typeof reply === "string" ? reply : reply(...capture));
    }
    return next();
  });
}
function apply(ctx, config = {}) {
  if (config.broadcast !== false)
    ctx.plugin(broadcast);
  if (config.contextify !== false)
    ctx.plugin(contextify);
  if (config.echo !== false)
    ctx.plugin(echo);
  if (!(config.recall <= 0))
    ctx.plugin(recall, config);
  const operators = (0, import_koishi_utils.makeArray)(config.operator);
  if (operators.length)
    ctx.plugin(feedback, operators);
  const relays = (0, import_koishi_utils.makeArray)(config.relay);
  if (relays.length)
    ctx.plugin(relay, relays);
  const respondents = (0, import_koishi_utils.makeArray)(config.respondent);
  if (respondents.length)
    ctx.plugin(respondent, respondents);
}

// packages/plugin-common/src/handler.ts
var import_koishi_core2 = __toModule(require("koishi-core"));
function onRepeat(options) {
  if (!options || typeof options !== "object")
    return options;
  const { minTimes, probability = 1 } = options;
  return ({ repeated, times, content }) => times >= minTimes && !repeated && import_koishi_core2.Random.bool(probability) ? content : "";
}
function repeater(ctx, config = {}) {
  ctx = ctx.group();
  const states = {};
  function getState(id) {
    return states[id] || (states[id] = {
      content: "",
      repeated: false,
      times: 0,
      users: {}
    });
  }
  ctx.before("send", ({ cid, content }) => {
    const state = getState(cid);
    state.repeated = true;
    if (state.content === content) {
      state.times += 1;
    } else {
      state.content = content;
      state.times = 1;
      state.users = {};
    }
  });
  ctx.middleware((session, next) => {
    const { content, uid, userId } = session;
    if (ctx.bots[uid])
      return;
    const state = getState(session.cid);
    const check = (handle) => {
      const text = handle == null ? void 0 : handle(state, session);
      return text && next(() => {
        ctx.emit("repeater", session, state);
        return session.send(text);
      });
    };
    if (content === state.content) {
      state.times += 1;
      state.users[userId] = (state.users[userId] || 0) + 1;
      return check(onRepeat(config.onRepeat)) || next();
    }
    const result = check(config.onInterrupt);
    if (result)
      return result;
    state.content = content;
    state.repeated = false;
    state.times = 1;
    state.users = { [userId]: 1 };
    return next();
  });
}
async function getHandlerResult(handler, session, prefer) {
  const result = typeof handler === "function" ? await handler(session) : handler;
  if (typeof result === "string") {
    return [prefer, result];
  } else if (typeof result === "boolean") {
    return [result];
  }
}
function verifier(ctx, config = {}) {
  ctx.on("friend-request", async (session) => {
    const result = await getHandlerResult(config.onFriendRequest, session, true);
    if (result)
      return session.bot.handleFriendRequest(session.messageId, ...result);
  });
  ctx.on("group-request", async (session) => {
    const result = await getHandlerResult(config.onGroupRequest, session, false);
    if (result)
      return session.bot.handleGroupRequest(session.messageId, ...result);
  });
  ctx.on("group-member-request", async (session) => {
    const result = await getHandlerResult(config.onGroupMemberRequest, session, false);
    if (result)
      return session.bot.handleGroupMemberRequest(session.messageId, ...result);
  });
}
function apply2(ctx, config) {
  ctx.plugin(repeater, config);
  ctx.plugin(verifier, config);
}

// packages/plugin-common/src/updater.ts
var import_koishi_utils2 = __toModule(require("koishi-utils"));
var import_koishi_core3 = __toModule(require("koishi-core"));
import_koishi_utils2.template.set("admin", {
  "unknown-flag": "未找到标记 {0}。",
  "all-flags": "全部标记为：{0}。",
  "no-flags": "未设置任何标记。",
  "current-flags": "当前的标记为：{0}。",
  "user-expected": "请指定目标用户。",
  "user-not-found": "未找到指定的用户。",
  "user-unchanged": "用户数据未改动。",
  "user-updated": "用户数据已修改。",
  "channel-not-found": "未找到指定的频道。",
  "channel-unchanged": "频道数据未改动。",
  "channel-updated": "频道数据已修改。",
  "invalid-assignee-platform": "代理者应与目标频道属于同一平台。",
  "not-in-group": "当前不在群组上下文中，请使用 -t 参数指定目标频道。"
});
import_koishi_utils2.template.set("callme", {
  "current": "好的呢，{0}！",
  "unnamed": "你还没有给自己起一个称呼呢~",
  "unchanged": "称呼未发生变化。",
  "empty": "称呼不能为空。",
  "invalid": "称呼中禁止包含纯文本以外的内容。",
  "duplicate": "禁止与其他用户重名。",
  "updated": "好的，{0}，请多指教！",
  "failed": "修改称呼失败。"
});
import_koishi_utils2.template.set("bind", {
  "generated-1": [
    "bind 指令可用于在多个平台间绑定用户数据。绑定过程中，源平台的用户数据将完全保留，而目标平台的用户数据将被源平台的数据所覆盖。",
    "请确认当前平台是你的目标平台，并在 5 分钟内使用你的账号在源平台内向机器人发送以下文本：",
    "{0}",
    "注意：每个账号只能绑定到每个平台一次，此操作将会抹去你当前平台上的数据，请谨慎操作！"
  ].join("\n"),
  "generated-2": [
    "令牌核验成功！下面将进行第二步操作。",
    "请在 5 分钟内使用你的账号在目标平台内向机器人发送以下文本：",
    "{0}",
    "注意：当前平台是你的源平台，这里的用户数据将完全保留，而目标平台的用户数据将被覆盖，请谨慎操作！"
  ].join("\n"),
  "failed": "账号绑定失败：你已经绑定过该平台。",
  "success": "账号绑定成功！"
});
import_koishi_utils2.template.set("usage", {
  "present": "今日 {0} 功能的调用次数为：{1}",
  "list": "今日各功能的调用次数为：",
  "none": "今日没有调用过消耗次数的功能。"
});
import_koishi_utils2.template.set("timer", {
  "present": "定时器 {0} 的生效时间为：剩余 {1}",
  "absent": "定时器 {0} 当前并未生效。",
  "list": "各定时器的生效时间为：",
  "none": "当前没有生效的定时器。"
});
import_koishi_utils2.template.set("switch", {
  "forbidden": "您无权修改 {0} 功能。",
  "list": "当前禁用的功能有：{0}",
  "none": "当前没有禁用功能。"
});
function flagAction(map, { target, options }, ...flags) {
  if (options.set || options.unset) {
    const notFound = (0, import_koishi_utils2.difference)(flags, (0, import_koishi_utils2.enumKeys)(map));
    if (notFound.length)
      return (0, import_koishi_utils2.template)("admin.unknown-flag", notFound.join(", "));
    for (const name2 of flags) {
      options.set ? target.flag |= map[name2] : target.flag &= ~map[name2];
    }
    return;
  }
  if (options.list) {
    return (0, import_koishi_utils2.template)("admin.all-flags", (0, import_koishi_utils2.enumKeys)(map).join(", "));
  }
  let flag = target.flag;
  const keys = [];
  while (flag) {
    const value = 2 ** Math.floor(Math.log2(flag));
    flag -= value;
    keys.unshift(map[value]);
  }
  if (!keys.length)
    return (0, import_koishi_utils2.template)("admin.no-flags");
  return (0, import_koishi_utils2.template)("admin.current-flags", keys.join(", "));
}
import_koishi_core3.Command.prototype.adminUser = function(callback, autoCreate) {
  this.config.checkUnknown = true;
  const command = this.userFields(["authority"]).option("target", "-t [user:user]  指定目标用户", { authority: 3 }).userFields(({ session, options }, fields) => {
    const platform = options.target ? options.target.split(":")[0] : session.platform;
    fields.add(platform);
  });
  command.action(async (argv) => {
    const { options, args, session: { user, database } } = argv;
    const fields = argv.session.collect("user", argv);
    let target, session = argv.session;
    if (!options.target) {
      target = await argv.session.observeUser(fields);
    } else {
      const [platform, userId] = import_koishi_core3.Argv.parsePid(options.target);
      if (user[platform] === userId) {
        target = await argv.session.observeUser(fields);
      } else {
        const data = await database.getUser(platform, userId, [...fields]);
        if (!data) {
          if (!autoCreate)
            return (0, import_koishi_utils2.template)("admin.user-not-found");
          const fallback = (0, import_koishi_utils2.observe)(import_koishi_core3.User.create(platform, userId), async () => {
            if (!fallback.authority)
              return;
            await database.createUser(platform, userId, fallback);
          });
          target = fallback;
        } else if (user.authority <= data.authority) {
          return (0, import_koishi_utils2.template)("internal.low-authority");
        } else {
          target = (0, import_koishi_utils2.observe)(data, (diff) => database.setUser(platform, userId, diff), `user ${options.target}`);
          if (!autoCreate) {
            session = Object.create(argv.session);
            session.user = target;
            session.uid = options.target;
            session.userId = userId;
            session.platform = platform;
          }
        }
      }
    }
    const diffKeys = Object.keys(target._diff);
    const result = await callback(__spreadProps(__spreadValues({}, argv), { target, session }), ...args);
    if (typeof result === "string")
      return result;
    if (!(0, import_koishi_utils2.difference)(Object.keys(target._diff), diffKeys).length) {
      return (0, import_koishi_utils2.template)("admin.user-unchanged");
    }
    await target._update();
    return (0, import_koishi_utils2.template)("admin.user-updated");
  });
  return command;
};
import_koishi_core3.Command.prototype.adminChannel = function(callback, autoCreate) {
  this.config.checkUnknown = true;
  const command = this.userFields(["authority"]).option("target", "-t [channel:channel]  指定目标频道", { authority: 3 });
  command.action(async (argv, ...args) => {
    const { options, session: { cid, subtype, database } } = argv;
    const fields = argv.session.collect("channel", argv);
    let target, session = argv.session;
    if ((!options.target || options.target === cid) && subtype === "group") {
      target = await argv.session.observeChannel(fields);
    } else if (options.target) {
      const [platform, channelId] = import_koishi_core3.Argv.parsePid(options.target);
      const data = await database.getChannel(platform, channelId, [...fields]);
      if (!data) {
        if (!autoCreate)
          return (0, import_koishi_utils2.template)("admin.channel-not-found");
        const fallback = (0, import_koishi_utils2.observe)(import_koishi_core3.Channel.create(platform, channelId), async () => {
          if (!fallback.assignee)
            return;
          await database.createChannel(platform, channelId, fallback);
        });
        target = fallback;
      } else {
        target = (0, import_koishi_utils2.observe)(data, (diff) => database.setChannel(platform, channelId, diff), `channel ${options.target}`);
        if (!autoCreate) {
          session = Object.create(argv.session);
          session.channel = target;
          session.cid = options.target;
          session.channelId = channelId;
          session.platform = platform;
        }
      }
    } else {
      return (0, import_koishi_utils2.template)("admin.not-in-group");
    }
    const result = await callback(__spreadProps(__spreadValues({}, argv), { target, session }), ...args);
    if (typeof result === "string")
      return result;
    if (!Object.keys(target._diff).length) {
      return (0, import_koishi_utils2.template)("admin.channel-unchanged");
    }
    await target._update();
    return (0, import_koishi_utils2.template)("admin.channel-updated");
  });
  return command;
};
function callme(ctx) {
  ctx = ctx.select("database");
  ctx.command("common/callme [name:text]", "修改自己的称呼").userFields(["id", "name"]).shortcut("叫我", { prefix: true, fuzzy: true }).action(async ({ session }, name2) => {
    const { user } = session;
    if (!name2) {
      if (user.name) {
        return (0, import_koishi_utils2.template)("callme.current", session.username);
      } else {
        return (0, import_koishi_utils2.template)("callme.unnamed");
      }
    } else if (name2 === user.name) {
      return (0, import_koishi_utils2.template)("callme.unchanged");
    } else if (!(name2 = name2.trim())) {
      return (0, import_koishi_utils2.template)("callme.empty");
    } else if (name2.includes("[CQ:")) {
      return (0, import_koishi_utils2.template)("callme.invalid");
    }
    const result = ctx.bail("common/callme", name2, session);
    if (result)
      return result;
    try {
      user.name = name2;
      await user._update();
      return (0, import_koishi_utils2.template)("callme.updated", session.username);
    } catch (error) {
      if (error[Symbol.for("koishi.error-type")] === "duplicate-entry") {
        return (0, import_koishi_utils2.template)("callme.duplicate");
      } else {
        ctx.logger("common").warn(error);
        return (0, import_koishi_utils2.template)("callme.failed");
      }
    }
  });
}
function bind(ctx, config = {}) {
  ctx = ctx.select("database");
  const tokens = {};
  const { generateToken = () => "koishi/" + import_koishi_utils2.Random.uuid() } = config;
  function generate(session, pending) {
    const token = generateToken();
    tokens[token] = [session.platform, session.userId, pending];
    setTimeout(() => delete tokens[token], 5 * import_koishi_utils2.Time.minute);
    return token;
  }
  async function bind2(user, platform, userId) {
    await ctx.database.remove("user", { [platform]: [userId] });
    ctx.app._userCache[platform].set(userId, user);
    user[platform] = userId;
    await user._update();
  }
  ctx.command("common/bind", "绑定到账号", { authority: 0 }).action(({ session }) => {
    const token = generate(session, +(session.subtype === "group"));
    return (0, import_koishi_utils2.template)("bind.generated-1", token);
  });
  ctx.middleware(async (session, next) => {
    const data = tokens[session.content];
    if (!data)
      return next();
    if (data[2] < 0) {
      const sess = new import_koishi_core3.Session(ctx.app, __spreadProps(__spreadValues({}, session), { platform: data[0], userId: data[1] }));
      const user = await sess.observeUser([session.platform]);
      delete tokens[session.content];
      await bind2(user, session.platform, session.userId);
      return session.send((0, import_koishi_utils2.template)("bind.success"));
    } else {
      const user = await session.observeUser(["authority", data[0]]);
      if (!user.authority)
        return session.send((0, import_koishi_utils2.template)("internal.low-authority"));
      if (user[data[0]])
        return session.send((0, import_koishi_utils2.template)("bind.failed"));
      delete tokens[session.content];
      if (data[2]) {
        const token = generate(session, -1);
        return session.send((0, import_koishi_utils2.template)("bind.generated-2", token));
      } else {
        await bind2(user, data[0], data[1]);
        return session.send((0, import_koishi_utils2.template)("bind.success"));
      }
    }
  }, true);
}
function admin(ctx) {
  ctx = ctx.select("database");
  ctx.command("common/user", "用户管理", { authority: 3 });
  ctx.command("common/channel", "频道管理", { authority: 3 });
  ctx.command("user/authorize <value:natural>", "权限信息", { authority: 4 }).alias("auth").adminUser(async ({ session, target }, authority) => {
    if (session.userId === target[session.platform])
      return (0, import_koishi_utils2.template)("admin.user-expected");
    if (authority >= session.user.authority)
      return (0, import_koishi_utils2.template)("internal.low-authority");
    if (authority === target.authority)
      return (0, import_koishi_utils2.template)("admin.user-unchanged");
    target.authority = authority;
  }, true);
  ctx.command("user.flag [-s|-S] [...flags]", "标记信息", { authority: 3 }).userFields(["flag"]).option("list", "-l  标记列表").option("set", "-s  添加标记", { authority: 4 }).option("unset", "-S  删除标记", { authority: 4 }).adminUser(flagAction.bind(null, import_koishi_core3.User.Flag));
  ctx.command("user.usage [key] [value:posint]", "调用次数信息", { authority: 1 }).userFields(["usage"]).option("set", "-s  设置调用次数", { authority: 4 }).option("clear", "-c  清空调用次数", { authority: 4 }).adminUser(({ target, options }, name2, count) => {
    if (options.clear) {
      name2 ? delete target.usage[name2] : target.usage = {};
      return;
    }
    if (options.set) {
      if (!count)
        return (0, import_koishi_utils2.template)("internal.insufficient-arguments");
      target.usage[name2] = count;
      return;
    }
    if (name2)
      return (0, import_koishi_utils2.template)("usage.present", name2, target.usage[name2] || 0);
    const output = [];
    for (const name3 of Object.keys(target.usage).sort()) {
      if (name3.startsWith("$"))
        continue;
      output.push(`${name3}：${target.usage[name3]}`);
    }
    if (!output.length)
      return (0, import_koishi_utils2.template)("usage.none");
    output.unshift((0, import_koishi_utils2.template)("usage.list"));
    return output.join("\n");
  });
  ctx.command("user.timer [key] [value:date]", "定时器信息", { authority: 1 }).userFields(["timers"]).option("set", "-s  设置定时器", { authority: 4 }).option("clear", "-c  清空定时器", { authority: 4 }).adminUser(({ target, options }, name2, value) => {
    if (options.clear) {
      name2 ? delete target.timers[name2] : target.timers = {};
      return;
    }
    if (options.set) {
      if (!value)
        return (0, import_koishi_utils2.template)("internal.insufficient-arguments");
      target.timers[name2] = +value;
      return;
    }
    const now = Date.now();
    if (name2) {
      const delta = target.timers[name2] - now;
      if (delta > 0)
        return (0, import_koishi_utils2.template)("timer.present", name2, import_koishi_utils2.Time.formatTime(delta));
      return (0, import_koishi_utils2.template)("timer.absent", name2);
    }
    const output = [];
    for (const name3 of Object.keys(target.timers).sort()) {
      if (name3.startsWith("$"))
        continue;
      output.push(`${name3}：剩余 ${import_koishi_utils2.Time.formatTime(target.timers[name3] - now)}`);
    }
    if (!output.length)
      return (0, import_koishi_utils2.template)("timer.none");
    output.unshift((0, import_koishi_utils2.template)("timer.list"));
    return output.join("\n");
  });
  ctx.command("channel/assign [bot:user]", "受理者账号", { authority: 4 }).channelFields(["assignee"]).option("noTarget", "-T  移除受理者").adminChannel(async ({ session, options, target }, value) => {
    if (options.noTarget) {
      target.assignee = "";
    } else if (!value) {
      target.assignee = session.selfId;
    } else {
      const [platform, userId] = import_koishi_core3.Argv.parsePid(value);
      if (platform !== import_koishi_core3.Argv.parsePid(options.target)[0]) {
        return (0, import_koishi_utils2.template)("admin.invalid-assignee-platform");
      }
      target.assignee = userId;
    }
  }, true);
  ctx.command("channel/switch <command...>", "启用和禁用功能", { authority: 3 }).channelFields(["disable"]).userFields(["authority"]).adminChannel(async ({ session, target }, ...names) => {
    if (!names.length) {
      if (!target.disable.length)
        return (0, import_koishi_utils2.template)("switch.none");
      return (0, import_koishi_utils2.template)("switch.list", target.disable.join(", "));
    }
    names = (0, import_koishi_utils2.deduplicate)(names);
    const forbidden = names.filter((name2) => {
      const command = ctx.app._commands.get(name2);
      return command && command.config.authority >= session.user.authority;
    });
    if (forbidden.length)
      return (0, import_koishi_utils2.template)("switch.forbidden", forbidden.join(", "));
    const add = (0, import_koishi_utils2.difference)(names, target.disable);
    const remove = (0, import_koishi_utils2.intersection)(names, target.disable);
    const preserve = (0, import_koishi_utils2.difference)(target.disable, names);
    const output = [];
    if (add.length)
      output.push(`禁用 ${add.join(", ")} 功能`);
    if (remove.length)
      output.push(`启用 ${remove.join(", ")} 功能`);
    target.disable = [...preserve, ...add];
    await target._update();
    return `已${output.join("，")}。`;
  });
  ctx.command("channel.flag [-s|-S] [...flags]", "标记信息", { authority: 3 }).channelFields(["flag"]).option("list", "-l  标记列表").option("set", "-s  添加标记", { authority: 4 }).option("unset", "-S  删除标记", { authority: 4 }).adminChannel(flagAction.bind(null, import_koishi_core3.Channel.Flag));
}
function apply3(ctx, config = {}) {
  if (config.admin !== false)
    ctx.plugin(admin);
  if (config.bind !== false)
    ctx.plugin(bind, config);
  if (config.callme !== false)
    ctx.plugin(callme);
}

// packages/plugin-common/src/index.ts
var name = "common";
function apply4(ctx, config = {}) {
  ctx.command("common", "基础功能");
  ctx.plugin(apply, config);
  ctx.plugin(apply2, config);
  ctx.plugin(apply3, config);
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  admin,
  apply,
  bind,
  broadcast,
  callme,
  contextify,
  echo,
  feedback,
  name,
  recall,
  relay,
  repeater,
  respondent,
  verifier
});
//# sourceMappingURL=index.js.map

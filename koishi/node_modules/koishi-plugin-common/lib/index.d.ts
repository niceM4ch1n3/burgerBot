import { Context, Session, Awaitable, User, Channel, Argv, Extend } from 'koishi-core';
import { Awaitable } from 'koishi-utils';
export function broadcast(ctx: Context): void;
export function contextify(ctx: Context): void;
export function echo(ctx: Context): void;
export function feedback(ctx: Context, operators: string[]): void;
export interface RecallConfig {
    recall?: number;
}
export function recall(ctx: Context, { recall }: RecallConfig): void;
interface RelayOptions {
    source: string;
    destination: string;
    selfId?: string;
    lifespan?: number;
}
export function relay(ctx: Context, relays: RelayOptions[]): void;
export interface Respondent {
    match: string | RegExp;
    reply: string | ((...capture: string[]) => string);
}
export function respondent(ctx: Context, respondents: Respondent[]): void;
export interface BasicConfig extends RecallConfig {
    echo?: boolean;
    broadcast?: boolean;
    contextify?: boolean;
    operator?: string | string[];
    relay?: RelayOptions | RelayOptions[];
    respondent?: Respondent | Respondent[];
}
declare module 'koishi-core' {
    interface EventMap {
        'repeater'(session: Session, state: RepeatState): void;
    }
}
interface RepeatState {
    content: string;
    repeated: boolean;
    times: number;
    users: Record<string, number>;
}
type StateCallback = (state: RepeatState, session: Session) => void | string;
interface RepeatHandler {
    minTimes: number;
    probability?: number;
}
export interface RepeaterConfig {
    onRepeat?: RepeatHandler | StateCallback;
    onInterrupt?: StateCallback;
}
export function repeater(ctx: Context, config?: RepeaterConfig): void;
type RequestHandler = string | boolean | ((session: Session) => Awaitable<string | boolean | void>);
export interface VerifierConfig {
    onFriendRequest?: RequestHandler;
    onGroupMemberRequest?: RequestHandler;
    onGroupRequest?: RequestHandler;
}
export function verifier(ctx: Context, config?: VerifierConfig): void;
export interface HandlerConfig extends RepeaterConfig, VerifierConfig {
}
type AdminAction<U extends User.Field, G extends Channel.Field, A extends any[], O extends {}, T> = (argv: Argv<U | 'authority', G, A, Extend<O, 'target', string>> & {
    target: T;
}, ...args: A) => Awaitable<void | string>;
declare module 'koishi-core' {
    interface Command<U, G, A, O> {
        adminUser(callback: AdminAction<U, G, A, O, User.Observed<U | 'authority'>>, autoCreate?: boolean): this;
        adminChannel(callback: AdminAction<U, G, A, O, Channel.Observed<G>>, autoCreate?: boolean): this;
    }
    interface EventMap {
        'common/callme'(name: string, session: Session): string | void;
    }
}
export function callme(ctx: Context): void;
export interface BindConfig {
    generateToken?: () => string;
}
export function bind(ctx: Context, config?: BindConfig): void;
export function admin(ctx: Context): void;
export interface UpdaterConfig extends BindConfig {
    admin?: boolean;
    bind?: boolean;
    callme?: boolean;
}
export interface Config extends HandlerConfig, BasicConfig, UpdaterConfig {
}
export const name = "common";
export function apply(ctx: Context, config?: Config): void;export default function apply(ctx: Context, config?: UpdaterConfig): void;

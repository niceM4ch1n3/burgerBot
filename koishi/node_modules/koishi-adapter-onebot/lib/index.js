var __create = Object.create;
var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, {enumerable: true, configurable: true, writable: true, value}) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __markAsModule = (target) => __defProp(target, "__esModule", {value: true});
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, {get: all[name], enumerable: true});
};
var __reExport = (target, module2, desc) => {
  if (module2 && typeof module2 === "object" || typeof module2 === "function") {
    for (let key of __getOwnPropNames(module2))
      if (!__hasOwnProp.call(target, key) && key !== "default")
        __defProp(target, key, {get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable});
  }
  return target;
};
var __toModule = (module2) => {
  return __reExport(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, "default", module2 && module2.__esModule && "default" in module2 ? {get: () => module2.default, enumerable: true} : {value: module2, enumerable: true})), module2);
};

// packages/adapter-onebot/src/index.ts
__markAsModule(exports);
__export(exports, {
  CQBot: () => CQBot,
  SafetyLevel: () => SafetyLevel,
  SenderError: () => SenderError,
  WsClient: () => WsClient,
  WsServer: () => WsServer,
  adaptAuthor: () => adaptAuthor,
  adaptChannel: () => adaptChannel,
  adaptGroup: () => adaptGroup,
  adaptGroupMember: () => adaptGroupMember,
  adaptMessage: () => adaptMessage,
  adaptUser: () => adaptUser,
  connect: () => connect,
  createSession: () => createSession,
  toVersion: () => toVersion
});
var import_koishi_core5 = __toModule(require("koishi-core"));

// packages/adapter-onebot/src/ws.ts
var import_koishi_core3 = __toModule(require("koishi-core"));
var import_koishi_utils2 = __toModule(require("koishi-utils"));

// packages/adapter-onebot/src/utils.ts
var import_koishi_core = __toModule(require("koishi-core"));
var import_koishi_utils = __toModule(require("koishi-utils"));
var qface = __toModule(require("qface"));

// packages/adapter-onebot/src/types.ts
var SafetyLevel;
(function(SafetyLevel2) {
  SafetyLevel2[SafetyLevel2["safe"] = 0] = "safe";
  SafetyLevel2[SafetyLevel2["unknown"] = 1] = "unknown";
  SafetyLevel2[SafetyLevel2["danger"] = 2] = "danger";
})(SafetyLevel || (SafetyLevel = {}));

// packages/adapter-onebot/src/utils.ts
var adaptUser = (user) => ({
  userId: user.userId.toString(),
  avatar: `http://q.qlogo.cn/headimg_dl?dst_uin=${user.userId}&spec=640`,
  username: user.nickname
});
var adaptGroupMember = (user) => __spreadProps(__spreadValues({}, adaptUser(user)), {
  nickname: user.card,
  roles: [user.role]
});
var adaptAuthor = (user, anonymous) => __spreadProps(__spreadValues({}, adaptUser(user)), {
  nickname: (anonymous == null ? void 0 : anonymous.name) || user.card,
  anonymous: anonymous == null ? void 0 : anonymous.flag,
  roles: [user.role]
});
function adaptMessage(message) {
  return {
    messageId: message.messageId.toString(),
    timestamp: message.time * 1e3,
    author: adaptAuthor(message.sender, message.anonymous),
    content: import_koishi_utils.segment.transform(message.message, {
      at({qq}) {
        if (qq !== "all")
          return import_koishi_utils.segment.at(qq);
        return (0, import_koishi_utils.segment)("at", {type: "all"});
      },
      face: ({id}) => (0, import_koishi_utils.segment)("face", {id, url: qface.getUrl(id)}),
      reply: (data) => (0, import_koishi_utils.segment)("quote", data)
    })
  };
}
var adaptGroup = (group) => ({
  groupId: group.groupId.toString(),
  groupName: group.groupName
});
var adaptChannel = (group) => ({
  channelId: group.groupId.toString(),
  channelName: group.groupName
});
function toVersion(data) {
  const {coolqEdition, pluginVersion, goCqhttp, version} = data;
  if (goCqhttp) {
    return `go-cqhttp/${version.slice(1)}`;
  } else {
    return `coolq/${coolqEdition} cqhttp/${pluginVersion}`;
  }
}
var logger = new import_koishi_utils.Logger("onebot");
function createSession(adapter, data) {
  const session = (0, import_koishi_utils.camelCase)(data);
  (0, import_koishi_utils.renameProperty)(session, "type", "postType");
  (0, import_koishi_utils.renameProperty)(session, "subtype", "subType");
  session.platform = "onebot";
  session.selfId = "" + session.selfId;
  if (session.userId)
    session.userId = "" + session.userId;
  if (session.groupId)
    session.groupId = session.channelId = "" + session.groupId;
  if (session.targetId)
    session.targetId = "" + session.targetId;
  if (session.operatorId)
    session.operatorId = "" + session.operatorId;
  if (session.type === "message") {
    Object.assign(session, adaptMessage(session));
    (0, import_koishi_utils.renameProperty)(session, "subtype", "messageType");
    session.channelId || (session.channelId = `private:${session.userId}`);
  } else if (data.post_type === "request") {
    delete session["requestType"];
    (0, import_koishi_utils.renameProperty)(session, "content", "comment");
    (0, import_koishi_utils.renameProperty)(session, "messageId", "flag");
    if (data.request_type === "friend") {
      session.type = "friend-request";
      session.channelId = `private:${session.userId}`;
    } else if (data.sub_type === "add") {
      session.type = "group-member-request";
    } else {
      session.type = "group-request";
    }
  } else if (data.post_type === "notice") {
    delete session["noticeType"];
    switch (data.notice_type) {
      case "group_recall":
        session.type = "message-deleted";
        session.subtype = "group";
        break;
      case "friend_recall":
        session.type = "message-deleted";
        session.subtype = "private";
        session.channelId = `private:${session.userId}`;
        break;
      case "friend_add":
        session.type = "friend-added";
        break;
      case "group_upload":
        session.type = "group-file-added";
        break;
      case "group_admin":
        session.type = "group-member";
        session.subtype = "role";
        break;
      case "group_ban":
        session.type = "group-member";
        session.subtype = "ban";
        break;
      case "group_decrease":
        session.type = session.userId === session.selfId ? "group-deleted" : "group-member-deleted";
        session.subtype = session.userId === session.operatorId ? "active" : "passive";
        break;
      case "group_increase":
        session.type = session.userId === session.selfId ? "group-added" : "group-member-added";
        session.subtype = session.userId === session.operatorId ? "active" : "passive";
        break;
      case "group_card":
        session.type = "group-member";
        session.subtype = "nickname";
        break;
      case "notify":
        session.type = "notice";
        session.subtype = (0, import_koishi_utils.paramCase)(data.sub_type);
        if (session.subtype === "poke") {
          session.channelId || (session.channelId = `private:${session.userId}`);
        } else if (session.subtype === "honor") {
          session.subsubtype = (0, import_koishi_utils.paramCase)(data.honor_type);
        }
        break;
    }
  } else
    return;
  return new import_koishi_core.Session(adapter.app, session);
}
var counter = 0;
var listeners = {};
function connect(bot) {
  return new Promise((resolve, reject) => {
    bot.socket.on("message", (data) => {
      data = data.toString();
      let parsed;
      try {
        parsed = JSON.parse(data);
      } catch (error) {
        return logger.warn("cannot parse message", data);
      }
      if ("post_type" in parsed) {
        logger.debug("receive %o", parsed);
        const session = createSession(bot.adapter, parsed);
        if (session)
          bot.adapter.dispatch(session);
      } else if (parsed.echo === -1) {
        Object.assign(bot, adaptUser((0, import_koishi_utils.camelCase)(parsed.data)));
        logger.debug("%d got self info", parsed.data);
        if (bot.server) {
          logger.info("connected to %c", bot.server);
        }
        resolve();
      } else if (parsed.echo in listeners) {
        listeners[parsed.echo](parsed);
        delete listeners[parsed.echo];
      }
    });
    bot.socket.on("close", () => {
      delete bot._request;
    });
    bot.socket.send(JSON.stringify({
      action: "get_login_info",
      echo: -1
    }), (error) => {
      if (error)
        reject(error);
    });
    bot._request = (action, params) => {
      const data = {action, params, echo: ++counter};
      data.echo = ++counter;
      return new Promise((resolve2, reject2) => {
        listeners[data.echo] = resolve2;
        setTimeout(() => {
          delete listeners[data.echo];
          reject2(new Error("response timeout"));
        }, bot.app.options.onebot.responseTimeout);
        bot.socket.send(JSON.stringify(data), (error) => {
          if (error)
            reject2(error);
        });
      });
    };
  });
}

// packages/adapter-onebot/src/bot.ts
var import_koishi_core2 = __toModule(require("koishi-core"));
var SenderError = class extends Error {
  constructor(args, url, retcode, selfId) {
    super(`Error when trying to send to ${url}, args: ${JSON.stringify(args)}, retcode: ${retcode}`);
    Object.defineProperties(this, {
      name: {value: "SenderError"},
      selfId: {value: selfId},
      code: {value: retcode},
      args: {value: args},
      url: {value: url}
    });
  }
};
function renderText(source) {
  return import_koishi_core2.segment.parse(source).reduce((prev, {type, data}) => {
    if (type === "at") {
      if (data.type === "all")
        return prev + "[CQ:at,qq=all]";
      return prev + `[CQ:at,qq=${data.id}]`;
    } else if (["video", "audio", "image"].includes(type)) {
      if (type === "audio")
        type = "record";
      if (!data.file)
        data.file = data.url;
    } else if (type === "quote") {
      type = "reply";
    }
    return prev + (0, import_koishi_core2.segment)(type, data);
  }, "");
}
var CQBot = class extends import_koishi_core2.Bot {
  constructor(adapter, options) {
    super(adapter, options);
    this.version = "onebot";
    this.avatar = `http://q.qlogo.cn/headimg_dl?dst_uin=${options.selfId}&spec=640`;
  }
  async [import_koishi_core2.Session.send](message, content) {
    var _a;
    if (!content)
      return;
    const {userId, groupId, channelId, channelName} = message;
    if (!((_a = this.app.options.onebot) == null ? void 0 : _a.quickOperation)) {
      await this.sendMessage(channelId, content);
      return;
    }
    let id;
    const session = this.createSession({content, channelId, channelName});
    if (groupId) {
      id = session.groupId = groupId;
      session.subtype = "group";
    } else {
      id = session.userId = userId;
      session.subtype = "private";
    }
    if (await this.app.serial(session, "before-send", session))
      return;
    content = renderText(session.content);
    if (message._response) {
      return message._response({reply: content, atSender: false});
    }
    return groupId ? this.$sendGroupMsgAsync(id, content) : this.$sendPrivateMsgAsync(id, content);
  }
  async get(action, params = {}, silent = false) {
    this.logger.debug("[request] %s %o", action, params);
    const response = await this._request(action, (0, import_koishi_core2.snakeCase)(params));
    this.logger.debug("[response] %o", response);
    const {data, retcode} = response;
    if (retcode === 0 && !silent) {
      return (0, import_koishi_core2.camelCase)(data);
    } else if (retcode < 0 && !silent) {
      throw new SenderError(params, action, retcode, this.selfId);
    } else if (retcode > 1) {
      throw new SenderError(params, action, retcode, this.selfId);
    }
  }
  async getAsync(action, params = {}) {
    await this.get(action + "_async", params);
  }
  sendMessage(channelId, content) {
    content = renderText(content);
    return channelId.startsWith("private:") ? this.sendPrivateMessage(channelId.slice(8), content) : this.sendGroupMessage(channelId, content);
  }
  async getMessage(channelId, messageId) {
    const data = await this.$getMsg(messageId);
    return adaptMessage(data);
  }
  async deleteMessage(channelId, messageId) {
    await this.$deleteMsg(messageId);
  }
  async getSelf() {
    const data = await this.$getLoginInfo();
    return adaptUser(data);
  }
  async getUser(userId) {
    const data = await this.$getStrangerInfo(userId);
    return adaptUser(data);
  }
  async getFriendList() {
    const data = await this.$getFriendList();
    return data.map(adaptUser);
  }
  async getChannel(channelId) {
    const data = await this.$getGroupInfo(channelId);
    return adaptChannel(data);
  }
  async getGroup(groupId) {
    const data = await this.$getGroupInfo(groupId);
    return adaptGroup(data);
  }
  async getGroupList() {
    const data = await this.$getGroupList();
    return data.map(adaptGroup);
  }
  async getGroupMember(groupId, userId) {
    const data = await this.$getGroupMemberInfo(groupId, userId);
    return adaptGroupMember(data);
  }
  async getGroupMemberList(groupId) {
    const data = await this.$getGroupMemberList(groupId);
    return data.map(adaptGroupMember);
  }
  async sendGroupMessage(groupId, content) {
    if (!content)
      return;
    const session = this.createSession({content, subtype: "group", groupId, channelId: groupId});
    if (this.app.bail(session, "before-send", session))
      return;
    session.messageId = "" + await this.$sendGroupMsg(groupId, content);
    this.app.emit(session, "send", session);
    return session.messageId;
  }
  async sendPrivateMessage(userId, content) {
    if (!content)
      return;
    const session = this.createSession({content, subtype: "private", userId, channelId: "private:" + userId});
    if (this.app.bail(session, "before-send", session))
      return;
    session.messageId = "" + await this.$sendPrivateMsg(userId, content);
    this.app.emit(session, "send", session);
    return session.messageId;
  }
  async $setGroupAnonymousBan(groupId, meta, duration) {
    const args = {groupId, duration};
    args[typeof meta === "string" ? "flag" : "anonymous"] = meta;
    await this.get("set_group_anonymous_ban", args);
  }
  $setGroupAnonymousBanAsync(groupId, meta, duration) {
    const args = {groupId, duration};
    args[typeof meta === "string" ? "flag" : "anonymous"] = meta;
    return this.getAsync("set_group_anonymous_ban", args);
  }
  async handleFriendRequest(messageId, approve, comment) {
    await this.$setFriendAddRequest(messageId, approve, comment);
  }
  async handleGroupRequest(messageId, approve, comment) {
    await this.$setGroupAddRequest(messageId, "invite", approve, comment);
  }
  async handleGroupMemberRequest(messageId, approve, comment) {
    await this.$setGroupAddRequest(messageId, "add", approve, comment);
  }
  async deleteFriend(userId) {
    await this.$deleteFriend(userId);
  }
  async getStatus() {
    if (this.status !== import_koishi_core2.Bot.Status.GOOD)
      return this.status;
    try {
      const data = await this.$getStatus();
      return data.good ? import_koishi_core2.Bot.Status.GOOD : data.online ? import_koishi_core2.Bot.Status.SERVER_ERROR : import_koishi_core2.Bot.Status.BOT_OFFLINE;
    } catch {
      return import_koishi_core2.Bot.Status.NET_ERROR;
    }
  }
};
var asyncPrefixes = ["$set", "$send", "$delete", "$create", "$upload"];
function prepareMethod(name) {
  const prop = "$" + (0, import_koishi_core2.camelCase)(name.replace(/^[_.]/, ""));
  const isAsync = asyncPrefixes.some((prefix) => prop.startsWith(prefix));
  return [prop, isAsync];
}
function define(name, ...params) {
  const [prop, isAsync] = prepareMethod(name);
  CQBot.prototype[prop] = async function(...args) {
    const data = await this.get(name, Object.fromEntries(params.map((name2, index) => [name2, args[index]])));
    if (!isAsync)
      return data;
  };
  isAsync && (CQBot.prototype[prop + "Async"] = async function(...args) {
    await this.getAsync(name, Object.fromEntries(params.map((name2, index) => [name2, args[index]])));
  });
}
function defineExtract(name, key, ...params) {
  key = (0, import_koishi_core2.camelCase)(key);
  const [prop, isAsync] = prepareMethod(name);
  CQBot.prototype[prop] = async function(...args) {
    const data = await this.get(name, Object.fromEntries(params.map((name2, index) => [name2, args[index]])));
    return data[key];
  };
  isAsync && (CQBot.prototype[prop + "Async"] = async function(...args) {
    await this.getAsync(name, Object.fromEntries(params.map((name2, index) => [name2, args[index]])));
  });
}
defineExtract("send_private_msg", "message_id", "user_id", "message", "auto_escape");
defineExtract("send_group_msg", "message_id", "group_id", "message", "auto_escape");
defineExtract("send_group_forward_msg", "message_id", "group_id", "messages");
define("delete_msg", "message_id");
define("set_essence_msg", "message_id");
define("delete_essence_msg", "message_id");
define("send_like", "user_id", "times");
define("get_msg", "message_id");
define("get_essence_msg_list", "group_id");
define("ocr_image", "image");
defineExtract("get_forward_msg", "messages", "message_id");
defineExtract(".get_word_slices", "slices", "content");
define("get_group_msg_history", "group_id", "message_seq");
define("set_friend_add_request", "flag", "approve", "remark");
define("set_group_add_request", "flag", "sub_type", "approve", "reason");
defineExtract("_get_model_show", "variants", "model");
define("_set_model_show", "model", "model_show");
define("set_group_kick", "group_id", "user_id", "reject_add_request");
define("set_group_ban", "group_id", "user_id", "duration");
define("set_group_whole_ban", "group_id", "enable");
define("set_group_admin", "group_id", "user_id", "enable");
define("set_group_anonymous", "group_id", "enable");
define("set_group_card", "group_id", "user_id", "card");
define("set_group_leave", "group_id", "is_dismiss");
define("set_group_special_title", "group_id", "user_id", "special_title", "duration");
define("set_group_name", "group_id", "group_name");
define("set_group_portrait", "group_id", "file", "cache");
define("_send_group_notice", "group_id", "content");
define("get_group_at_all_remain", "group_id");
define("get_login_info");
define("get_stranger_info", "user_id", "no_cache");
define("_get_vip_info", "user_id");
define("get_friend_list");
define("get_group_info", "group_id", "no_cache");
define("get_group_list");
define("get_group_member_info", "group_id", "user_id", "no_cache");
define("get_group_member_list", "group_id");
define("get_group_honor_info", "group_id", "type");
define("get_group_system_msg");
define("get_group_file_system_info", "group_id");
define("get_group_root_files", "group_id");
define("get_group_files_by_folder", "group_id", "folder_id");
define("upload_group_file", "group_id", "file", "name", "folder");
define("create_group_file_folder", "group_id", "folder_id", "name");
define("delete_group_folder", "group_id", "folder_id");
define("delete_group_file", "group_id", "folder_id", "file_id", "busid");
defineExtract("get_group_file_url", "url", "group_id", "file_id", "busid");
defineExtract("download_file", "file", "url", "headers", "thread_count");
defineExtract("get_online_clients", "clients", "no_cache");
defineExtract("check_url_safely", "level", "url");
define("delete_friend", "user_id");
defineExtract("get_cookies", "cookies", "domain");
defineExtract("get_csrf_token", "token");
define("get_credentials", "domain");
define("get_record", "file", "out_format", "full_path");
define("get_image", "file");
defineExtract("can_send_image", "yes");
defineExtract("can_send_record", "yes");
define("get_status");
define("get_version_info");
define("set_restart", "delay");
define("reload_event_filter");

// packages/adapter-onebot/src/ws.ts
var import_ws = __toModule(require("ws"));
var logger2 = new import_koishi_utils2.Logger("onebot");
var WsClient = class extends import_koishi_core3.Adapter.WsClient {
  constructor(app) {
    super(app, CQBot, app.options.onebot);
    this.connect = connect;
  }
  prepare(bot) {
    const headers = {};
    if (bot.token)
      headers.Authorization = `Bearer ${bot.token}`;
    return new import_ws.default(bot.server, {headers});
  }
};
var WsServer = class extends import_koishi_core3.Adapter {
  constructor(app) {
    (0, import_koishi_utils2.assertProperty)(app.options, "port");
    super(app, CQBot);
    const {onebot = {}} = this.app.options;
    const {path = "/onebot"} = onebot;
    this.wsServer = new import_ws.default.Server({
      path,
      server: this.app._httpServer
    });
  }
  start() {
    return new Promise((resolve, reject) => {
      this.wsServer.on("error", reject);
      this.wsServer.on("connection", (socket, {headers}) => {
        logger2.debug("connected with", headers);
        if (headers["x-client-role"] !== "Universal") {
          return socket.close(1008, "invalid x-client-role");
        }
        const selfId = headers["x-self-id"].toString();
        const bot = this.bots[selfId];
        if (!bot)
          return socket.close(1008, "invalid x-self-id");
        bot.socket = socket;
        connect(bot).then(() => {
          if (this.bots.every(({version, server}) => version || server === null))
            resolve();
        }, reject);
      });
    });
  }
  stop() {
    logger2.debug("ws server closing");
    this.wsServer.close();
    for (const bot of this.bots) {
      bot.socket = null;
    }
  }
};

// packages/adapter-onebot/src/http.ts
var import_koishi_core4 = __toModule(require("koishi-core"));
var import_koishi_utils3 = __toModule(require("koishi-utils"));
var import_crypto = __toModule(require("crypto"));
var import_axios = __toModule(require("axios"));
var logger3 = new import_koishi_utils3.Logger("onebot");
var HttpServer = class extends import_koishi_core4.Adapter {
  constructor(app) {
    (0, import_koishi_utils3.assertProperty)(app.options, "port");
    super(app, CQBot);
  }
  async _listen(bot) {
    if (!bot.server)
      return;
    bot.status = import_koishi_core4.Bot.Status.GOOD;
    bot._request = async (action, params) => {
      const headers = {"Content-Type": "application/json"};
      if (bot.token) {
        headers.Authorization = `Token ${bot.token}`;
      }
      const uri = new URL(action, bot.server).href;
      const {data} = await import_axios.default.post(uri, params, {headers});
      return data;
    };
    Object.assign(bot, await bot.getSelf());
    logger3.info("connected to %c", bot.server);
  }
  async start() {
    const {onebot = {}} = this.app.options;
    const {secret, path = "/onebot"} = onebot;
    this.app.router.post(path, (ctx) => {
      if (secret) {
        const signature = ctx.headers["x-signature"];
        if (!signature)
          return ctx.status = 401;
        const sig = (0, import_crypto.createHmac)("sha1", secret).update(ctx.request.rawBody).digest("hex");
        if (signature !== `sha1=${sig}`)
          return ctx.status = 403;
      }
      logger3.debug("receive %o", ctx.request.body);
      const session = createSession(this, ctx.request.body);
      const {quickOperation} = onebot;
      if (session && quickOperation > 0) {
        ctx.respond = false;
        ctx.res.writeHead(200, {
          "Content-Type": "application/json"
        });
        (0, import_koishi_utils3.defineProperty)(session, "$response", (data) => {
          session._response = null;
          clearTimeout(timer);
          ctx.res.write(JSON.stringify((0, import_koishi_utils3.snakeCase)(data)));
          ctx.res.end();
        });
        const timer = setTimeout(() => {
          session._response = null;
          ctx.res.end();
        }, quickOperation);
      }
      if (session)
        this.dispatch(session);
    });
    await Promise.all(this.bots.map((bot) => this._listen(bot)));
  }
  stop() {
    logger3.debug("http server closing");
  }
};
var http_default = HttpServer;

// packages/adapter-onebot/src/index.ts
var import_axios2 = __toModule(require("axios"));
import_koishi_core5.App.defaultConfig.onebot = {
  responseTimeout: import_koishi_core5.Time.minute
};
import_koishi_core5.Adapter.types["onebot:http"] = http_default;
import_koishi_core5.Adapter.types["onebot:ws"] = WsClient;
import_koishi_core5.Adapter.types["onebot:ws-reverse"] = WsServer;
import_koishi_core5.Adapter.types["onebot"] = import_koishi_core5.Adapter.redirect((bot) => {
  return !bot.server ? "onebot:ws-reverse" : bot.server.startsWith("ws") ? "onebot:ws" : "onebot:http";
});
var {broadcast} = import_koishi_core5.Context.prototype;
var imageRE = /\[CQ:image,file=([^,]+),url=([^\]]+)\]/;
import_koishi_core5.Context.prototype.broadcast = async function(...args) {
  const index = Array.isArray(args[0]) ? 1 : 0;
  let message = args[index];
  let output = "";
  let capture;
  while (capture = imageRE.exec(message)) {
    const [text, , url] = capture;
    output += message.slice(0, capture.index);
    message = message.slice(capture.index + text.length);
    const {data} = await import_axios2.default.get(url, {responseType: "arraybuffer"});
    output += `[CQ:image,file=base64://${Buffer.from(data).toString("base64")}]`;
  }
  args[index] = output + message;
  return broadcast.apply(this, args);
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  CQBot,
  SafetyLevel,
  SenderError,
  WsClient,
  WsServer,
  adaptAuthor,
  adaptChannel,
  adaptGroup,
  adaptGroupMember,
  adaptMessage,
  adaptUser,
  connect,
  createSession,
  toVersion
});
//# sourceMappingURL=index.js.map
